"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FFmpegBridge = exports.ffmpegExporterPlugin = void 0;
const ffmpeg_1 = require("@revideo/ffmpeg");
function ffmpegExporterPlugin({ output }) {
    return {
        name: 'revideo/ffmpeg',
        configureServer(server) {
            new FFmpegBridge(server.ws, { output });
        },
    };
}
exports.ffmpegExporterPlugin = ffmpegExporterPlugin;
/**
 * A simple bridge between the FFmpegExporterServer and FFmpegExporterClient.
 *
 * @remarks
 * This class lets the client exporter invoke methods on the server and receive
 * responses using a simple Promise-based API.
 */
class FFmpegBridge {
    constructor(ws, config) {
        this.ws = ws;
        this.config = config;
        this.process = null;
        this.handleMessage = async ({ method, data }) => {
            if (method === 'start') {
                try {
                    this.process = new ffmpeg_1.FFmpegExporterServer({
                        ...data,
                        ...this.config,
                    });
                    this.respondSuccess(method, await this.process.start());
                }
                catch (e) {
                    this.respondError(method, e?.message);
                }
                return;
            }
            if (!this.process) {
                this.respondError(method, 'The exporting process has not been started.');
                return;
            }
            if (!(method in this.process)) {
                this.respondError(method, `Unknown method: "${method}".`);
                return;
            }
            try {
                this.respondSuccess(method, await this.process[method](data));
            }
            catch (e) {
                this.respondError(method, e?.message);
            }
            if (method === 'kill') {
                this.process = null;
                return;
            }
        };
        // List of VideoFrameExtractors
        this.videoFrameExtractors = new Map();
        this.handleVideoFrameMessage = async ({ data }) => {
            const typedData = data;
            // Check if we already have a VideoFrameExtractor for this video
            const id = typedData.filePath + '-' + typedData.id;
            let extractor = this.videoFrameExtractors.get(id);
            const frameDuration = 1 / typedData.fps;
            const isOldFrame = extractor &&
                Math.abs(typedData.startTime - extractor.getLastTime()) <
                    frameDuration / 2;
            // If time has not changed, return the last frame
            if (isOldFrame) {
                const frame = extractor.getLastFrame();
                this.ws.send('revideo:ffmpeg-video-frame-res', {
                    status: 'success',
                    data: {
                        frame,
                    },
                });
                return;
            }
            // If the video has skipped back we need to create a new extractor
            if (extractor &&
                typedData.startTime + frameDuration < extractor.getTime()) {
                extractor.destroy();
                this.videoFrameExtractors.delete(id);
                extractor = undefined;
            }
            // If the video has skipped forward we need to create a new extractor
            if (extractor &&
                typedData.startTime > extractor.getTime() + frameDuration) {
                extractor.destroy();
                this.videoFrameExtractors.delete(id);
                extractor = undefined;
            }
            if (!extractor) {
                extractor = new ffmpeg_1.VideoFrameExtractor(typedData.filePath, typedData.startTime, typedData.fps, typedData.duration, typedData.png);
                this.videoFrameExtractors.set(id, extractor);
            }
            // Go to the frame that is closest to the requested time
            const frame = await extractor.popImage();
            this.ws.send('revideo:ffmpeg-video-frame-res', {
                status: 'success',
                data: {
                    frame,
                },
            });
        };
        this.handleRenderFinished = async () => {
            this.videoFrameExtractors.forEach(extractor => extractor.destroy());
            this.videoFrameExtractors.clear();
        };
        ws.on('revideo:ffmpeg-exporter', this.handleMessage);
        ws.on('revideo:ffmpeg-video-frame', this.handleVideoFrameMessage);
        ws.on('revideo:render-finished', this.handleRenderFinished);
    }
    respondSuccess(method, data = {}) {
        this.ws.send('revideo:ffmpeg-exporter-ack', {
            status: 'success',
            method,
            data,
        });
    }
    respondError(method, message = 'Unknown error.') {
        this.ws.send('revideo:ffmpeg-exporter-ack', {
            status: 'error',
            method,
            message,
        });
    }
}
exports.FFmpegBridge = FFmpegBridge;
//# sourceMappingURL=ffmpegExporter.js.map