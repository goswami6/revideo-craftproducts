"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.webglPlugin = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const source_map_1 = require("source-map");
const vite_1 = require("vite");
const GLSL_EXTENSION_REGEX = /\.glsl(?:$|\?)/;
const INCLUDE_REGEX = /^#include "([^"]+)"/;
function webglPlugin() {
    let config;
    return {
        name: 'revideo:webgl',
        configResolved(resolvedConfig) {
            config = resolvedConfig;
        },
        async transform(code, id) {
            if (!GLSL_EXTENSION_REGEX.test(id)) {
                return;
            }
            const [base, query] = id.split('?');
            const { dir } = path_1.default.posix.parse(base);
            const params = new URLSearchParams(query);
            if (params.has('raw')) {
                return;
            }
            const context = {
                rootDir: dir,
                fileStack: [],
                includeMap: new Map(),
                watchFile: file => this.addWatchFile(file),
                resolve: async (source, importer) => {
                    const resolved = await this.resolve(source, importer);
                    return resolved?.id;
                },
            };
            const glslSource = await resolveGlsl(context, id, code);
            const sourceUrl = (0, vite_1.normalizePath)(path_1.default.relative(config.root, base));
            const result = glslSource.toStringWithSourceMap();
            const map = result.map.toJSON();
            map.includeMap = Object.fromEntries(context.includeMap);
            return {
                map,
                code: `export default \`${result.code}\n//# sourceURL=${sourceUrl}\`;`,
            };
        },
    };
}
exports.webglPlugin = webglPlugin;
async function resolveGlsl(context, id, code) {
    const lines = code.split(/\r?\n/);
    const source = new source_map_1.SourceNode(1, 0, '', '');
    if (context.fileStack.includes(id)) {
        throw new Error(`Circular dependency detected: ${context.fileStack.join(' -> ')}`);
    }
    context.fileStack.push(id);
    const sourceMapId = path_1.default.posix.relative(context.rootDir, id);
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const match = line.match(INCLUDE_REGEX);
        if (match) {
            const childId = await context.resolve(match[1], id);
            if (!childId) {
                continue;
            }
            const childSourceMapId = path_1.default.posix.relative(context.rootDir, childId);
            if (context.includeMap.has(childSourceMapId)) {
                continue;
            }
            context.includeMap.set(childSourceMapId, [sourceMapId, i + 1]);
            context.watchFile(childId);
            const childCode = await fs_1.default.promises.readFile(childId, 'utf-8');
            source.add(await resolveGlsl(context, childId, childCode));
        }
        else {
            let j = 0;
            for (; j < line.length; j++) {
                source.add(new source_map_1.SourceNode(i + 1, j, sourceMapId, line[j]));
            }
            source.add(new source_map_1.SourceNode(i + 1, j, sourceMapId, '\n'));
        }
    }
    context.fileStack.pop();
    return source;
}
//# sourceMappingURL=webgl.js.map