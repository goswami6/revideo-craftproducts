import { MetaField } from '../meta';
import { Exporter } from './Exporter';
import { Project } from './Project';
import type { AssetInfo, RendererResult, RendererSettings } from './Renderer';
/**
 * FFmpeg video exporter.
 *
 * @remarks
 * Most of the export logic is handled on the server. This class communicates
 * with the FFmpegBridge through a WebSocket connection which lets it invoke
 * methods on the FFmpegExporterServer class.
 *
 * For example, calling the following method:
 * ```ts
 * async this.invoke('process', 7);
 * ```
 * Will invoke the `process` method on the FFmpegExporterServer class with `7`
 * as the argument. The result of the method will be returned as a Promise.
 *
 * Before any methods can be invoked, the FFmpegExporterServer class must be
 * initialized by invoking `start`.
 */
export declare class FFmpegExporterClient implements Exporter {
    private readonly project;
    private readonly settings;
    static readonly id = "@revideo/core/ffmpeg";
    static readonly displayName = "Video (FFmpeg)";
    static meta(project: Project): MetaField<any>;
    static create(project: Project, settings: RendererSettings): Promise<FFmpegExporterClient>;
    private static readonly response;
    constructor(project: Project, settings: RendererSettings);
    start(): Promise<void>;
    handleFrame(canvas: HTMLCanvasElement): Promise<void>;
    private blobToDataUrl;
    stop(result: RendererResult): Promise<void>;
    kill(): Promise<void>;
    generateAudio(assets: AssetInfo[][], startFrame: number, endFrame: number): Promise<void>;
    mergeMedia(): Promise<void>;
    /**
     * Remotely invoke a method on the server and wait for a response.
     *
     * @param method - The method name to execute on the server.
     * @param data - The data that will be passed as an argument to the method.
     *               Should be serializable.
     */
    private invoke;
}
//# sourceMappingURL=FFmpegExporter.d.ts.map