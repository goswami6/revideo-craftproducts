import { clampRemap, Color, map, unwrap, Vector2, } from '@revideo/core';
import { parseCodeFragment } from './CodeFragment';
import { isCodeScope } from './CodeScope';
import { isPointInCodeSelection } from './CodeSelection';
/**
 * A stateful class for recursively traversing a code scope.
 *
 * @internal
 */
export class CodeCursor {
    constructor(node) {
        this.node = node;
        this.cursor = new Vector2();
        this.beforeCursor = new Vector2();
        this.afterCursor = new Vector2();
        this.beforeIndex = 0;
        this.afterIndex = 0;
        this.context = {};
        this.monoWidth = 0;
        this.maxWidth = 0;
        this.lineHeight = 0;
        this.fallbackFill = new Color('white');
        this.caches = null;
        this.highlighter = null;
        this.selection = [];
        this.selectionProgress = null;
        this.globalProgress = [];
        this.fragmentDrawingInfo = [];
        this.fontHeight = 0;
        this.verticalOffset = 0;
    }
    /**
     * Prepare the cursor for the next traversal.
     *
     * @param context - The context used to measure and draw the code.
     */
    setupMeasure(context) {
        const metrics = context.measureText('X');
        this.monoWidth = metrics.width;
        this.fontHeight =
            metrics.fontBoundingBoxDescent + metrics.fontBoundingBoxAscent;
        this.verticalOffset = metrics.fontBoundingBoxAscent;
        this.context = context;
        this.lineHeight = parseFloat(this.node.styles.lineHeight);
        this.cursor = new Vector2();
        this.beforeCursor = new Vector2();
        this.afterCursor = new Vector2();
        this.beforeIndex = 0;
        this.afterIndex = 0;
        this.maxWidth = 0;
    }
    setupDraw(context) {
        this.setupMeasure(context);
        const fill = this.node.fill();
        this.fallbackFill =
            fill instanceof Color ? fill : new Color('white');
        this.caches = this.node.highlighterCache();
        this.highlighter = this.node.highlighter();
        this.selection = this.node.selection();
        this.selectionProgress = this.node.selectionProgress();
        this.fragmentDrawingInfo = [];
        this.globalProgress = [];
    }
    /**
     * Measure the desired size of the code scope.
     *
     * @remarks
     * The result can be retrieved with {@link getSize}.
     *
     * @param scope - The code scope to measure.
     */
    measureSize(scope) {
        const progress = unwrap(scope.progress);
        for (const wrapped of scope.fragments) {
            const possibleFragment = unwrap(wrapped);
            if (isCodeScope(possibleFragment)) {
                this.measureSize(possibleFragment);
                continue;
            }
            if (Array.isArray(possibleFragment)) {
                this.measureSize({
                    progress: scope.progress,
                    fragments: possibleFragment,
                });
                continue;
            }
            const fragment = parseCodeFragment(possibleFragment, this.context, this.monoWidth);
            const beforeMaxWidth = this.calculateMaxWidth(fragment.before);
            const afterMaxWidth = this.calculateMaxWidth(fragment.after);
            const maxWidth = map(beforeMaxWidth, afterMaxWidth, progress);
            if (maxWidth > this.maxWidth) {
                this.maxWidth = maxWidth;
            }
            const beforeEnd = this.calculateWidth(fragment.before);
            const afterEnd = this.calculateWidth(fragment.after);
            this.cursor.x = map(beforeEnd, afterEnd, progress);
            if (this.cursor.y === 0) {
                this.cursor.y = 1;
            }
            this.cursor.y += map(fragment.before.newRows, fragment.after.newRows, progress);
        }
    }
    /**
     * Get the size measured by the cursor.
     */
    getSize() {
        return {
            x: this.maxWidth * this.monoWidth,
            y: this.cursor.y * this.lineHeight + this.verticalOffset,
        };
    }
    /**
     * Get the drawing information created by the cursor.
     */
    getDrawingInfo() {
        return {
            fragments: this.fragmentDrawingInfo,
            verticalOffset: this.verticalOffset,
            fontHeight: this.fontHeight,
        };
    }
    /**
     * Draw the given code scope.
     *
     * @param scope - The code scope to draw.
     */
    drawScope(scope) {
        const progress = unwrap(scope.progress);
        for (const wrappedFragment of scope.fragments) {
            const possibleFragment = unwrap(wrappedFragment);
            if (isCodeScope(possibleFragment)) {
                this.drawScope(possibleFragment);
                continue;
            }
            if (Array.isArray(possibleFragment)) {
                this.drawScope({
                    progress: scope.progress,
                    fragments: possibleFragment,
                });
                continue;
            }
            const fragment = parseCodeFragment(possibleFragment, this.context, this.monoWidth);
            const timingOffset = 0.8;
            let alpha = 1;
            let offsetY = 0;
            if (fragment.before.content !== fragment.after.content) {
                const mirrored = Math.abs(progress - 0.5) * 2;
                alpha = clampRemap(1, 1 - timingOffset, 1, 0, mirrored);
                const scale = progress < 0.5 ? 4 : -4;
                offsetY = map(Math.abs(fragment.after.newRows - fragment.before.newRows) / scale, 0, mirrored);
            }
            this.drawToken(fragment, scope, this.cursor.addY(offsetY), alpha);
            this.beforeCursor.x = this.calculateWidth(fragment.before, this.beforeCursor.x);
            this.afterCursor.x = this.calculateWidth(fragment.after, this.afterCursor.x);
            this.beforeCursor.y += fragment.before.newRows;
            this.afterCursor.y += fragment.after.newRows;
            this.beforeIndex += fragment.before.content.length;
            this.afterIndex += fragment.after.content.length;
            this.cursor.y += map(fragment.before.newRows, fragment.after.newRows, progress);
            const beforeEnd = this.calculateWidth(fragment.before);
            const afterEnd = this.calculateWidth(fragment.after);
            this.cursor.x = map(beforeEnd, afterEnd, progress);
        }
    }
    drawToken(fragment, scope, offset, alpha) {
        const progress = unwrap(scope.progress);
        const currentProgress = this.currentProgress();
        if (progress > 0) {
            this.globalProgress.push(progress);
        }
        const code = progress < 0.5 ? fragment.before : fragment.after;
        let hasOffset = true;
        let width = 0;
        let stringLength = 0;
        let y = 0;
        for (let i = 0; i < code.content.length; i++) {
            let color = this.fallbackFill.serialize();
            let char = code.content.charAt(i);
            const selection = {
                before: null,
                after: null,
            };
            if (char === '\n') {
                y++;
                hasOffset = false;
                width = 0;
                stringLength = 0;
                selection.before = null;
                selection.after = null;
                continue;
            }
            const beforeHighlight = this.caches &&
                this.highlighter?.highlight(this.beforeIndex + i, this.caches.before);
            const afterHighlight = this.caches &&
                this.highlighter?.highlight(this.afterIndex + i, this.caches.after);
            const highlight = progress < 0.5 ? beforeHighlight : afterHighlight;
            if (highlight) {
                // Handle edge cases where the highlight style changes despite the
                // content being the same. The code doesn't fade in and out so the color
                // has to be interpolated to avoid jarring changes.
                if (fragment.before.content === fragment.after.content &&
                    beforeHighlight?.color !== afterHighlight?.color) {
                    highlight.color = Color.lerp(beforeHighlight?.color ?? this.fallbackFill, afterHighlight?.color ?? this.fallbackFill, progress).serialize();
                }
                if (highlight.color) {
                    color = highlight.color;
                }
                let skipAhead = 0;
                do {
                    if (this.processSelection(selection, skipAhead, hasOffset, stringLength, y)) {
                        break;
                    }
                    skipAhead++;
                } while (skipAhead < highlight.skipAhead);
                if (skipAhead > 1) {
                    char = code.content.slice(i, i + skipAhead);
                }
                i += char.length - 1;
            }
            else {
                this.processSelection(selection, 0, hasOffset, stringLength, y);
                let skipAhead = 1;
                while (i < code.content.length - 1 &&
                    code.content.charAt(i + 1) !== '\n') {
                    if (this.processSelection(selection, skipAhead, hasOffset, stringLength, y)) {
                        break;
                    }
                    skipAhead++;
                    char += code.content.charAt(++i);
                }
            }
            let time;
            const selectionAfter = selection.after ?? 0;
            const selectionBefore = selection.before ?? 0;
            if (fragment.before.content === '') {
                time = selectionAfter;
            }
            else if (fragment.after.content === '') {
                time = selectionBefore;
            }
            else {
                time = map(selectionBefore, selectionAfter, this.selectionProgress ?? currentProgress);
            }
            const measure = this.context.measureText(char);
            this.fragmentDrawingInfo.push({
                text: char,
                position: new Vector2((hasOffset ? offset.x + width : width) * this.monoWidth, (offset.y + y) * this.lineHeight),
                cursor: new Vector2(hasOffset ? this.beforeCursor.x + stringLength : stringLength, this.beforeCursor.y + y),
                alpha,
                characterSize: new Vector2(measure.width / char.length, this.fontHeight),
                fill: color,
                time,
            });
            stringLength += char.length;
            width += Math.round(measure.width / this.monoWidth);
        }
    }
    calculateWidth(metrics, x = this.cursor.x) {
        return metrics.newRows === 0 ? x + metrics.lastWidth : metrics.lastWidth;
    }
    calculateMaxWidth(metrics, x = this.cursor.x) {
        return Math.max(this.maxWidth, metrics.maxWidth, x + metrics.firstWidth);
    }
    currentProgress() {
        if (this.globalProgress.length === 0) {
            return 0;
        }
        let sum = 0;
        for (const progress of this.globalProgress) {
            sum += progress;
        }
        return sum / this.globalProgress.length;
    }
    processSelection(selection, skipAhead, hasOffset, stringLength, y) {
        let shouldBreak = false;
        let currentSelected = this.isSelected((hasOffset ? this.beforeCursor.x + stringLength : stringLength) +
            skipAhead, this.beforeCursor.y + y);
        if (selection.before !== null && selection.before !== currentSelected) {
            shouldBreak = true;
        }
        else {
            selection.before = currentSelected;
        }
        currentSelected = this.isSelected((hasOffset ? this.afterCursor.x + stringLength : stringLength) +
            skipAhead, this.afterCursor.y + y, true);
        if (selection.after !== null && selection.after !== currentSelected) {
            shouldBreak = true;
        }
        else {
            selection.after = currentSelected;
        }
        return shouldBreak;
    }
    isSelected(x, y, isAfter) {
        const point = [y, x];
        const maxSelection = isPointInCodeSelection(point, this.selection) ? 1 : 0;
        if (this.node.oldSelection === null || this.selectionProgress === null) {
            return maxSelection;
        }
        if (isAfter) {
            return maxSelection;
        }
        return isPointInCodeSelection(point, this.node.oldSelection) ? 1 : 0;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29kZUN1cnNvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29kZS9Db2RlQ3Vyc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxVQUFVLEVBQ1YsS0FBSyxFQUNMLEdBQUcsRUFFSCxNQUFNLEVBQ04sT0FBTyxHQUNSLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBZSxpQkFBaUIsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBSS9ELE9BQU8sRUFBWSxXQUFXLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDbkQsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFZdkQ7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyxVQUFVO0lBb0JyQixZQUFvQyxJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQW5CdkMsV0FBTSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7UUFDdkIsaUJBQVksR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQzdCLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUM1QixnQkFBVyxHQUFHLENBQUMsQ0FBQztRQUNoQixlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsWUFBTyxHQUFHLEVBQThCLENBQUM7UUFDekMsY0FBUyxHQUFHLENBQUMsQ0FBQztRQUNkLGFBQVEsR0FBRyxDQUFDLENBQUM7UUFDYixlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsaUJBQVksR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsQyxXQUFNLEdBQTZDLElBQUksQ0FBQztRQUN4RCxnQkFBVyxHQUEyQixJQUFJLENBQUM7UUFDM0MsY0FBUyxHQUFnQixFQUFFLENBQUM7UUFDNUIsc0JBQWlCLEdBQWtCLElBQUksQ0FBQztRQUN4QyxtQkFBYyxHQUFhLEVBQUUsQ0FBQztRQUM5Qix3QkFBbUIsR0FBOEIsRUFBRSxDQUFDO1FBQ3BELGVBQVUs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