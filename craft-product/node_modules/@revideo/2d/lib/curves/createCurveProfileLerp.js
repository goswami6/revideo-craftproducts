import { Vector2 } from '@revideo/core';
import { LineSegment } from './LineSegment';
import { getPointAtDistance } from './getPointAtDistance';
import { getPolylineProfile } from './getPolylineProfile';
/**
 * Split segments of polygon until distance between adjacent point is less than or equal maxLength. This function mutate original points.
 * @param points - Polygon points
 * @param maxLength - max distance between two point
 */
function bisect(points, maxLength) {
    for (let i = 0; i < points.length - 1; i++) {
        const a = points[i];
        let b = points[i + 1];
        while (a.sub(b).magnitude > maxLength) {
            b = Vector2.lerp(a, b, 0.5);
            points.splice(i + 1, 0, b);
        }
    }
}
/**
 * Convert curve which only contain LineSegment into polygon.
 * @param curve - curve to convert. curve must contain 1 subpath
 * @param maxLength - max distance between two point
 * @returns - null if curve contain segment other than LineSegment
 */
function exactPolygonPoints(curve, maxLength) {
    const points = [];
    let endPoint = null;
    for (const segment of curve.segments) {
        if (!(segment instanceof LineSegment))
            return null;
        points.push(segment.from);
        endPoint = segment.to;
    }
    if (endPoint)
        points.push(endPoint);
    if (!Number.isNaN(maxLength) && maxLength > 0) {
        bisect(points, maxLength);
    }
    return points;
}
/**
 * Calculate area of polygon
 * @param points - polygon points
 * @returns - area of polygon
 */
function polygonArea(points) {
    return (points.reduce((area, a, i) => {
        const b = points[(i + 1) % points.length];
        return area + (a.y * b.x - a.x * b.y);
    }, 0) / 2);
}
/**
 * Convert curve into polygon by sampling curve profile
 * @param curve - curve to convert. curve must contain only 1 subpath
 * @param maxLength - max distance between point
 * @returns - always return polygon points
 */
function approximatePolygonPoints(curve, maxLength) {
    const points = [];
    let numPoints = 3;
    if (!Number.isNaN(maxLength) && maxLength > 0) {
        numPoints = Math.max(numPoints, Math.ceil(curve.arcLength / maxLength));
    }
    for (let i = 0; i < numPoints; i += 1) {
        const point = getPointAtDistance(curve, curve.arcLength * (i / (numPoints - 1)));
        points.push(point.position);
    }
    if (polygonArea(points) > 0)
        points.reverse();
    return points;
}
/**
 * Split curve into subpaths
 * @param curve - curve to split
 * @returns - subpaths of curve
 */
function splitCurve(curve) {
    if (curve.segments.length === 0)
        return [];
    let current = {
        arcLength: 0,
        minSin: 0,
        segments: [],
        closed: false,
    };
    let endPoint = null;
    const composite = [current];
    for (const segment of curve.segments) {
        const start = segment.getPoint(0).position;
        if (endPoint && !start.equals(endPoint)) {
            current = {
                arcLength: 0,
                minSin: 0,
                segments: [],
                closed: false,
            };
            composite.push(current);
        }
        current.segments.push(segment);
        current.arcLength += segment.arcLength;
        endPoint = segment.getPoint(1).position;
    }
    for (const sub of composite) {
        sub.closed = sub.segments[0]
            .getPoint(0)
            .position.equals(sub.segments[sub.segments.length - 1].getPoint(1).position);
    }
    return composite;
}
/**
 * Convert curve into polygon use best possible method
 * @param curve - curve to convert
 * @param maxLength - max distance between two point
 * @returns - polgon points
 */
function subcurveToPolygon(curve, maxLength) {
    const points = exactPolygonPoints(curve, maxLength) ||
        approximatePolygonPoints(curve, maxLength);
    return {
        points: [...points],
        closed: curve.closed,
    };
}
/**
 * Calculate polygon perimeter
 * @param points - polygon points
 * @returns - perimeter of polygon
 */
export function polygonLength(points) {
    return points.reduce((length, point, i) => {
        if (i)
            return length + points[i - 1].sub(point).magnitude;
        return 0;
    }, 0);
}
/**s
 * Sample additional points for polygon to better match its pair. This will mutate original points.
 * @param points - polygon points
 * @param numPoints - number of points to be added
 */
function addPoints(points, numPoints) {
    const desiredLength = points.length + numPoints;
    const step = polygonLength(points) / numPoints;
    let i = 0;
    let cursor = 0;
    let insertAt = step / 2;
    while (points.length < desiredLength) {
        const a = points[i];
        const b = points[(i + 1) % points.length];
        const length = a.sub(b).magnitude;
        if (insertAt <= cursor + length) {
            points.splice(i + 1, 0, length
                ? Vector2.lerp(a, b, (insertAt - cursor) / length)
                : new Vector2(a));
            insertAt += step;
        }
        else {
            cursor += length;
            i += 1;
        }
    }
}
/**
 * Calculate total moving point distance when morphing between polygon points
 * @param points - first polygon points
 * @param reference - second polygon points
 * @param offset - offset for first polygon points
 * @returns
 */
export function calculateLerpDistance(points, reference, offset) {
    const len = points.length;
    let sumOfSquares = 0;
    for (let i = 0; i < reference.length; i += 1) {
        const a = points[(offset + i) % len];
        const b = reference[i];
        sumOfSquares += a.sub(b).squaredMagnitude;
    }
    return sumOfSquares;
}
/**
 * Rotate polygon in order to minimize moving points.
 * @param polygon - polygon to be rotated
 * @param reference - polygon to be reference
 */
function rotatePolygon(polygon, reference) {
    const { points, closed } = polygon;
    const len = points.length;
    if (!closed) {
        const originalDistance = calculateLerpDistance(points, reference.points, 0);
        const reversedPoints = [...points].reverse();
        const reversedDistance = calculateLerpDistance(reversedPoints, reference.points, 0);
        if (reversedDistance < originalDistance)
            polygon.points = reversedPoints;
    }
    else {
        let minDistance = Infinity;
        let bestOffset = 0;
        const last = points.pop();
        // Closed polygon first point must equal last point
        // When we rotate polygon, first point is changed which mean last point also must changed
        // When we remove last point, calculateLerpDistance will assume last point is equal first point
        // Proof:
        // len = points.length = reference.length - 1
        // When i = 0:
        // (offset + i) % len = offset % len
        // When i = reference.length - 1 or i = len
        // (offset + i) % len = (offset + len) % len = offset % len
        for (let offset = 0; offset < len; offset += 1) {
            const distance = calculateLerpDistance(points, reference.points, offset);
            if (distance < minDistance) {
                minDistance = distance;
                bestOffset = offset;
            }
        }
        if (last)
            points.push(last);
        if (bestOffset) {
            points.pop();
            const spliced = points.splice(0, bestOffset);
            points.splice(points.length, 0, ...spliced);
            points.push(points[0]);
        }
    }
}
/**
 * Round polygon's points coordinate to a specified amount of decimal
 * @param points - polygon point to be rounded
 * @param round - amount of decimal
 * @returns - new polygon point
 */
function roundPolygon({ points, ...rest }, round) {
    const pow = round >= 1 ? 10 ** round : 1;
    return {
        points: points.map(point => {
            const [x, y] = [point.x, point.y].map(n => Math.round(n * pow) / pow);
            return new Vector2(x, y);
        }),
        ...rest,
    };
}
/**
 * Create two polygon to tween between sub curve/path
 * @param from - source curve
 * @param to - targe curve
 * @param precision - desired distance between two point
 * @param round - amount of decimal when rounding
 * @returns two polygon ready to tween
 */
function getSubcurveInterpolationPolygon(from, to, precision, round) {
    const morphPrecision = precision;
    const fromRing = subcurveToPolygon(from, morphPrecision);
    const toRing = subcurveToPolygon(to, morphPrecision);
    const diff = fromRing.points.length - toRing.points.length;
    addPoints(fromRing.points, diff < 0 ? diff * -1 : 0);
    addPoints(toRing.points, diff > 0 ? diff : 0);
    if (!from.closed && to.closed)
        rotatePolygon(toRing, fromRing);
    else
        rotatePolygon(fromRing, toRing);
    return {
        from: roundPolygon(fromRing, round),
        to: roundPolygon(toRing, round),
    };
}
/**
 * Make two sub curve list have equal length
 * @param subcurves - List to add
 * @param reference - Reference list
 */
function balanceSubcurves(subcurves, reference) {
    for (let i = subcurves.length; i < reference.length; i++) {
        const point = reference[i].segments[0].getPoint(0).position;
        subcurves.push({
            arcLength: 0,
            closed: false,
            minSin: 0,
            segments: [new LineSegment(point, point)],
        });
    }
}
/**
 * Create two polygon to tween between curve
 * @param from - source curve
 * @param to - targe curve
 * @param precision - desired distance between two point
 * @param round - amount of decimal when rounding
 * @returns list that contain list of polygon before and after tween
 */
function getInterpolationPolygon(from, to, precision, round) {
    const fromSub = splitCurve(from);
    const toSub = splitCurve(to);
    if (fromSub.length < toSub.length)
        balanceSubcurves(fromSub, toSub);
    else
        balanceSubcurves(toSub, fromSub);
    return fromSub.map((sub, i) => getSubcurveInterpolationPolygon(sub, toSub[i], precision, round));
}
/**
 * Add curve into another curve
 * @param target - target curve
 * @param source - curve to add
 */
function addCurveToCurve(target, source) {
    const { segments, arcLength, minSin } = source;
    target.segments.push(...segments);
    target.arcLength += arcLength;
    target.minSin = Math.min(target.minSin, minSin);
}
/**
 * Interpolate between two polygon points.
 * @param from - source polygon points
 * @param to - target polygon points
 * @param value - interpolation progress
 * @returns - new polygon points
 */
export function polygonPointsLerp(from, to, value) {
    const points = [];
    if (value === 0)
        return [...from];
    if (value === 1)
        return [...to];
    for (let i = 0; i < from.length; i++) {
        const a = from[i];
        const b = to[i];
        points.push(Vector2.lerp(a, b, value));
    }
    return points;
}
/**
 * Create interpolator to tween between two curve
 * @param a - source curve
 * @param b - target curve
 * @returns - curve interpolator
 */
export function createCurveProfileLerp(a, b) {
    const interpolations = getInterpolationPolygon(a, b, 5, 4);
    return (progress) => {
        const curve = {
            segments: [],
            arcLength: 0,
            minSin: 1,
        };
        for (const { from, to } of interpolations) {
            const points = polygonPointsLerp(from.points, to.points, progress);
            addCurveToCurve(curve, getPolylineProfile(points, 0, false));
        }
        return curve;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlQ3VydmVQcm9maWxlTGVycC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY3VydmVzL2NyZWF0ZUN1cnZlUHJvZmlsZUxlcnAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUV0QyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzFDLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ3hELE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBZ0J4RDs7OztHQUlHO0FBRUgsU0FBUyxNQUFNLENBQUMsTUFBaUIsRUFBRSxTQUFpQjtJQUNsRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUMzQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEIsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN0QixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLFNBQVMsRUFBRSxDQUFDO1lBQ3RDLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDNUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM3QixDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7R0FLRztBQUVILFNBQVMsa0JBQWtCLENBQ3pCLEtBQXNCLEVBQ3RCLFNBQWlCO0lBRWpCLE1BQU0sTUFBTSxHQUFjLEVBQUUsQ0FBQztJ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