import { Vector2, clamp } from '@revideo/core';
import { CubicBezierSegment } from './CubicBezierSegment';
import { QuadBezierSegment } from './QuadBezierSegment';
function isCubicSegment(segment) {
    return segment instanceof CubicBezierSegment;
}
/**
 * Update a given knot's handles to be a blend between the user provided handles
 * and a set of auto calculated handles that smoothly connect the knot to its
 * two neighboring knots.
 *
 * @param knot - The knot for which to calculate the handles
 * @param previous - The previous knot in the spline, relative to the provided
 *                   knot.
 * @param next - The next knot in the spline, relative to the provided knot.
 * @param smoothness - The desired smoothness of the spline. Affects the scaling
 *                     of the auto calculated handles.
 */
function calculateSmoothHandles(knot, previous, next, smoothness) {
    if (knot.auto.start === 0 && knot.auto.end === 0) {
        return;
    }
    // See for reference:
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    const distanceToPrev = knot.position.sub(previous.position).magnitude;
    const distanceToNext = next.position.sub(knot.position).magnitude;
    const fa = (smoothness * distanceToPrev) / (distanceToPrev + distanceToNext);
    const fb = smoothness - fa;
    const startHandle = new Vector2(knot.position.x - fa * (next.position.x - previous.position.x), knot.position.y - fa * (next.position.y - previous.position.y));
    const endHandle = new Vector2(knot.position.x + fb * (next.position.x - previous.position.x), knot.position.y + fb * (next.position.y - previous.position.y));
    knot.startHandle = knot.startHandle.lerp(startHandle, knot.auto.start);
    knot.endHandle = knot.endHandle.lerp(endHandle, knot.auto.end);
}
/**
 * Calculate the `minSin` value of the curve profile so that miter joins get
 * taken into account properly.
 */
function updateMinSin(profile) {
    for (let i = 0; i < profile.segments.length; i++) {
        const segmentA = profile.segments[i];
        const segmentB = profile.segments[(i + 1) % profile.segments.length];
        // Quadratic Bézier segments will always join smoothly with the previous
        // segment. This means that we can skip the segment since it's impossible
        // to have a miter join between the two segments.
        if (!isCubicSegment(segmentA) || !isCubicSegment(segmentB)) {
            continue;
        }
        const startVector = segmentA.p2.sub(segmentA.p3).normalized.safe;
        const endVector = segmentB.p1.sub(segmentB.p0).normalized.safe;
        const dot = startVector.dot(endVector);
        // A miter join can only occur if the handle is broken, so we can skip the
        // segment if the handles are mirrored.
        const isBroken = 1 - Math.abs(dot) > 0.0001;
        if (!isBroken) {
            continue;
        }
        const angleBetween = Math.acos(clamp(-1, 1, dot));
        const angleSin = Math.sin(angleBetween / 2);
        profile.minSin = Math.min(profile.minSin, Math.abs(angleSin));
    }
}
function addSegmentToProfile(profile, p0, p1, p2, p3) {
    const segment = p3 !== undefined
        ? new CubicBezierSegment(p0, p1, p2, p3)
        : new QuadBezierSegment(p0, p1, p2);
    profile.segments.push(segment);
    profile.arcLength += segment.arcLength;
}
/**
 * Calculate the curve profile of a spline based on a set of knots.
 *
 * @param knots - The knots defining the spline
 * @param closed - Whether the spline should be closed or not
 * @param smoothness - The desired smoothness of the spline when using auto
 *                     calculated handles.
 */
export function getBezierSplineProfile(knots, closed, smoothness) {
    const profile = {
        segments: [],
        arcLength: 0,
        minSin: 1,
    };
    // First, we want to calculate the actual handle positions for each knot. We
    // do so using the knot's `auto` value to blend between the user-provided
    // handles and the auto calculated smooth handles.
    const numberOfKnots = knots.length;
    for (let i = 0; i < numberOfKnots; i++) {
        // Calculating the auto handles for a given knot requires both of the knot's
        // neighboring knots. To make sure that this works properly for the first
        // and last knots of the spline, we want to make sure to wrap around to the
        // beginning and end of the array, respectively.
        const prevIndex = (i - 1 + numberOfKnots) % numberOfKnots;
        const nextIndex = (i + 1) % numberOfKnots;
        calculateSmoothHandles(knots[i], knots[prevIndex], knots[nextIndex], smoothness);
    }
    const firstKnot = knots[0];
    const secondKnot = knots[1];
    // Drawing the first and last segments of a spline has a few edge cases we
    // need to consider:
    // If the spline is not closed and the first knot should use the auto
    // calculated handles, we want to draw a quadratic Bézier curve instead of a
    // cubic one.
    if (!closed && firstKnot.auto.start === 1 && firstKnot.auto.end === 1) {
        addSegmentToProfile(profile, firstKnot.position, secondKnot.startHandle, secondKnot.position);
    }
    else {
        // Otherwise, draw a cubic Bézier segment like we do for the other segments.
        addSegmentToProfile(profile, firstKnot.position, firstKnot.endHandle, secondKnot.startHandle, secondKnot.position);
    }
    // Add all intermediate spline segments as cubic Bézier curve segments.
    for (let i = 1; i < numberOfKnots - 2; i++) {
        const start = knots[i];
        const end = knots[i + 1];
        addSegmentToProfile(profile, start.position, start.endHandle, end.startHandle, end.position);
    }
    const lastKnot = knots.at(-1);
    const secondToLastKnot = knots.at(-2);
    if (knots.length > 2) {
        // Similar to the first segment, we also want to draw the last segment as a
        // quadratic Bézier curve if the curve is not closed and the knot should
        // use the auto calculated handles.
        if (!closed && lastKnot.auto.start === 1 && lastKnot.auto.end === 1) {
            addSegmentToProfile(profile, secondToLastKnot.position, secondToLastKnot.endHandle, lastKnot.position);
        }
        else {
            addSegmentToProfile(profile, secondToLastKnot.position, secondToLastKnot.endHandle, lastKnot.startHandle, lastKnot.position);
        }
    }
    // If the spline should be closed, add one final cubic Bézier segment
    // connecting the last and first knots.
    if (closed) {
        addSegmentToProfile(profile, lastKnot.position, lastKnot.endHandle, firstKnot.startHandle, firstKnot.position);
    }
    updateMinSin(profile);
    return profile;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0QmV6aWVyU3BsaW5lUHJvZmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY3VydmVzL2dldEJlemllclNwbGluZVByb2ZpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDN0MsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFJeEQsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFFdEQsU0FBUyxjQUFjLENBQ3JCLE9BQTBCO0lBRTFCLE9BQU8sT0FBTyxZQUFZLGtCQUFrQixDQUFDO0FBQy9DLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILFNBQVMsc0JBQXNCLENBQzdCLElBQWMsRUFDZCxRQUFrQixFQUNsQixJQUFjLEVBQ2QsVUFBa0I7SUFFbEIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDakQsT0FBTztJQUNULENBQUM7SUFFRCxxQkFBcUI7SUFDckIsa0VBQWtFO0lBQ2xFLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDdEUsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQztJQUNsRSxNQUFNLEVBQUUsR0FBRyxDQUFDLFVBQVUsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUMsQ0FBQztJQUM3RSxNQUFNLEVBQUUsR0FBRyxVQUFVLEdBQUcsRUFBRSxDQUFDO0lBQzNCLE1BQU0sV0FBVyxHQUFHLElB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