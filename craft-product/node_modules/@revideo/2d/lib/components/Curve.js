var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Vector2, clamp, } from '@revideo/core';
import { getPointAtDistance } from '../curves/getPointAtDistance';
import { computed, initial, nodeName, signal } from '../decorators';
import { lineTo, moveTo, resolveCanvasStyle } from '../utils';
import { Shape } from './Shape';
let Curve = class Curve extends Shape {
    desiredSize() {
        return this.childrenBBox().size;
    }
    constructor(props) {
        super(props);
        this.canHaveSubpath = false;
    }
    /**
     * Convert a percentage along the curve to a distance.
     *
     * @remarks
     * The returned distance is given in relation to the full curve, not
     * accounting for {@link startOffset} and {@link endOffset}.
     *
     * @param value - The percentage along the curve.
     */
    percentageToDistance(value) {
        return clamp(0, this.baseArcLength(), this.startOffset() + this.offsetArcLength() * value);
    }
    /**
     * Convert a distance along the curve to a percentage.
     *
     * @remarks
     * The distance should be given in relation to the full curve, not
     * accounting for {@link startOffset} and {@link endOffset}.
     *
     * @param value - The distance along the curve.
     */
    distanceToPercentage(value) {
        return (value - this.startOffset()) / this.offsetArcLength();
    }
    /**
     * The base arc length of this curve.
     *
     * @remarks
     * This is the entire length of this curve, not accounting for
     * {@link startOffset | the offsets}.
     */
    baseArcLength() {
        return this.profile().arcLength;
    }
    /**
     * The offset arc length of this curve.
     *
     * @remarks
     * This is the length of the curve that accounts for
     * {@link startOffset | the offsets}.
     */
    offsetArcLength() {
        const startOffset = this.startOffset();
        const endOffset = this.endOffset();
        const baseLength = this.baseArcLength();
        return clamp(0, baseLength, baseLength - startOffset - endOffset);
    }
    /**
     * The visible arc length of this curve.
     *
     * @remarks
     * This arc length accounts for both the offset and the {@link start} and
     * {@link end} properties.
     */
    arcLength() {
        return this.offsetArcLength() * Math.abs(this.start() - this.end());
    }
    /**
     * The percentage of the curve that's currently visible.
     *
     * @remarks
     * The returned value is the ratio between the visible length (as defined by
     * {@link start} and {@link end}) and the offset length of the curve.
     */
    completion() {
        return Math.abs(this.start() - this.end());
    }
    processSubpath(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _path, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _startPoint, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _endPoint) {
        // do nothing
    }
    curveDrawingInfo() {
        const path = new Path2D();
        let subpath = new Path2D();
        const profile = this.profile();
        let start = this.percentageToDistance(this.start());
        let end = this.percentageToDistance(this.end());
        if (start > end) {
            [start, end] = [end, start];
        }
        const distance = end - start;
        const arrowSize = Math.min(distance / 2, this.arrowSize());
        if (this.startArrow()) {
            start += arrowSize / 2;
        }
        if (this.endArrow()) {
            end -= arrowSize / 2;
        }
        let length = 0;
        let startPoint = null;
        let startTangent = null;
        let endPoint = null;
        let endTangent = null;
        for (const segment of profile.segments) {
            const previousLength = length;
            length += segment.arcLength;
            if (length < start) {
                continue;
            }
            const relativeStart = (start - previousLength) / segment.arcLength;
            const relativeEnd = (end - previousLength) / segment.arcLength;
            const clampedStart = clamp(0, 1, relativeStart);
            const clampedEnd = clamp(0, 1, relativeEnd);
            if (this.canHaveSubpath &&
                endPoint &&
                !segment.getPoint(0).position.equals(endPoint)) {
                path.addPath(subpath);
                this.processSubpath(subpath, startPoint, endPoint);
                subpath = new Path2D();
                startPoint = null;
            }
            const [startCurvePoint, endCurvePoint] = segment.draw(subpath, clampedStart, clampedEnd, startPoint === null);
            if (startPoint === null) {
                startPoint = startCurvePoint.position;
                startTangent = startCurvePoint.normal.flipped.perpendicular;
            }
            endPoint = endCurvePoint.position;
            endTangent = endCurvePoint.normal.flipped.perpendicular;
            if (length > end) {
                break;
            }
        }
        if (this.closed() &&
            this.start.isInitial() &&
            this.end.isInitial() &&
            this.startOffset.isInitial() &&
            this.endOffset.isInitial()) {
            subpath.closePath();
        }
        this.processSubpath(subpath, startPoint, endPoint);
        path.addPath(subpath);
        return {
            startPoint: startPoint ?? Vector2.zero,
            startTangent: startTangent ?? Vector2.right,
            endPoint: endPoint ?? Vector2.zero,
            endTangent: endTangent ?? Vector2.right,
            arrowSize,
            path,
            startOffset: start,
        };
    }
    getPointAtDistance(value) {
        return getPointAtDistance(this.profile(), value + this.startOffset());
    }
    getPointAtPercentage(value) {
        return getPointAtDistance(this.profile(), this.percentageToDistance(value));
    }
    getComputedLayout() {
        return this.offsetComputedLayout(super.getComputedLayout());
    }
    offsetComputedLayout(box) {
        box.position = box.position.sub(this.childrenBBox().center);
        return box;
    }
    getPath() {
        return this.curveDrawingInfo().path;
    }
    getCacheBBox() {
        const box = this.childrenBBox();
        const arrowSize = this.startArrow() || this.endArrow() ? this.arrowSize() : 0;
        const lineWidth = this.lineWidth();
        const coefficient = this.lineWidthCoefficient();
        return box.expand(Math.max(0, arrowSize, lineWidth * coefficient));
    }
    lineWidthCoefficient() {
        return this.lineCap() === 'square' ? 0.5 * 1.4143 : 0.5;
    }
    /**
     * Check if the path requires a profile.
     *
     * @remarks
     * The profile is only required if certain features are used. Otherwise, the
     * profile generation can be skipped, and the curve can be drawn directly
     * using the 2D context.
     */
    requiresProfile() {
        return (!this.start.isInitial() ||
            !this.startOffset.isInitial() ||
            !this.startArrow.isInitial() ||
            !this.end.isInitial() ||
            !this.endOffset.isInitial() ||
            !this.endArrow.isInitial());
    }
    drawShape(context) {
        super.drawShape(context);
        if (this.startArrow() || this.endArrow()) {
            this.drawArrows(context);
        }
    }
    drawArrows(context) {
        const { startPoint, startTangent, endPoint, endTangent, arrowSize } = this.curveDrawingInfo();
        if (arrowSize < 0.001) {
            return;
        }
        context.save();
        context.beginPath();
        if (this.endArrow()) {
            this.drawArrow(context, endPoint, endTangent.flipped, arrowSize);
        }
        if (this.startArrow()) {
            this.drawArrow(context, startPoint, startTangent, arrowSize);
        }
        context.fillStyle = resolveCanvasStyle(this.stroke(), context);
        context.closePath();
        context.fill();
        context.restore();
    }
    drawArrow(context, center, tangent, arrowSize) {
        const normal = tangent.perpendicular;
        const origin = center.add(tangent.scale(-arrowSize / 2));
        moveTo(context, origin);
        lineTo(context, origin.add(tangent.add(normal).scale(arrowSize)));
        lineTo(context, origin.add(tangent.sub(normal).scale(arrowSize)));
        lineTo(context, origin);
        context.closePath();
    }
};
__decorate([
    initial(false),
    signal()
], Curve.prototype, "closed", void 0);
__decorate([
    initial(0),
    signal()
], Curve.prototype, "start", void 0);
__decorate([
    initial(0),
    signal()
], Curve.prototype, "startOffset", void 0);
__decorate([
    initial(false),
    signal()
], Curve.prototype, "startArrow", void 0);
__decorate([
    initial(1),
    signal()
], Curve.prototype, "end", void 0);
__decorate([
    initial(0),
    signal()
], Curve.prototype, "endOffset", void 0);
__decorate([
    initial(false),
    signal()
], Curve.prototype, "endArrow", void 0);
__decorate([
    initial(24),
    signal()
], Curve.prototype, "arrowSize", void 0);
__decorate([
    computed()
], Curve.prototype, "arcLength", null);
__decorate([
    computed()
], Curve.prototype, "curveDrawingInfo", null);
Curve = __decorate([
    nodeName('Curve')
], Curve);
export { Curve };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3VydmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL2NvbXBvbmVudHMvQ3VydmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBTyxFQUtMLE9BQU8sRUFDUCxLQUFLLEdBQ04sTUFBTSxlQUFlLENBQUM7QUFJdkIsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDaEUsT0FBTyxFQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUVsRSxPQUFPLEVBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxrQkFBa0IsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUM1RCxPQUFPLEVBQUMsS0FBSyxFQUFhLE1BQU0sU0FBUyxDQUFDO0FBc0NuQyxJQUFlLEtBQUssR0FBcEIsTUFBZSxLQUFNLFNBQVEsS0FBSztJQTRHcEIsV0FBVztRQUM1QixPQUFPLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUM7SUFDbEMsQ0FBQztJQUVELFlBQW1CLEtBQWlCO1FBQ2xDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQVBMLG1CQUFjLEdBQUcsS0FBSyxDQUFDO0lBUWpDLENBQUM7SUFNRDs7Ozs7Ozs7T0FRRztJQUNJLG9CQUFvQixDQUFDLEtBQWE7UUFDdkMsT0FBTyxLQUFLLENBQ1YsQ0FBQyxFQUNELElBQUksQ0FBQyxhQUFhLEVBQUUsRUFDcEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsR0FBRyxLQUFLLENBQ3BELENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxvQkFBb0IsQ0FBQyxLQUFhO1FBQ3ZDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQy9ELENBQUM7SUFFRDs7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