var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BBox, createSignal, ExperimentalError, lazy, map, unwrap, } from '@revideo/core';
import { CodeCursor, codeSignal, CodeSignalContext, DefaultHighlightStyle, findAllCodeRanges, isPointInCodeSelection, LezerHighlighter, lines, parseCodeSelection, resolveScope, } from '../code';
import { computed, initial, nodeName, parser, signal } from '../decorators';
import { useScene2D } from '../scenes';
import { Shape } from './Shape';
/**
 * A node for displaying and animating code.
 *
 * @experimental
 *
 * @preview
 * ```tsx editor
 * import {parser} from '@lezer/javascript';
 * import {Code, LezerHighlighter, makeScene2D} from '@revideo/2d';
 * import {createRef} from '@revideo/core';
 *
 * export default makeScene2D(function* (view) {
 *   LezerHighlighter.registerParser(parser);
 *   const code = createRef<Code>();
 *
 *   view.add(
 *     <Code
 *       ref={code}
 *       offset={-1}
 *       position={view.size().scale(-0.5).add(60)}
 *       fontFamily={'JetBrains Mono, monospace'}
 *       fontSize={36}
 *       code={`\
 * function hello() {
 *   console.log('Hello');
 * }`}
 *     />,
 *   );
 *
 *   yield* code()
 *     .code(
 *       `\
 * function hello() {
 *   console.warn('Hello World');
 * }`,
 *       1,
 *     )
 *     .wait(0.5)
 *     .back(1)
 *     .wait(0.5);
 * });
 * ```
 */
let Code = class Code extends Shape {
    /**
     * Create a standalone code signal.
     *
     * @param initial - The initial code.
     * @param highlighter - Custom highlighter to use.
     * @param dialect - Custom dialect to use.
     */
    static createSignal(initial, highlighter, dialect) {
        return new CodeSignalContext(initial, undefined, highlighter, dialect).toSignal();
    }
    *tweenSelection(value, duration, timingFunction) {
        this.oldSelection = this.selection();
        this.selection(value);
        this.selectionProgress(0);
        yield* this.selectionProgress(1, duration, timingFunction);
        this.selectionProgress(null);
        this.oldSelection = null;
    }
    /**
     * Get the currently displayed code as a string.
     */
    parsed() {
        return resolveScope(this.code(), scope => unwrap(scope.progress) > 0.5);
    }
    highlighterCache() {
        const highlighter = this.highlighter();
        if (!highlighter || !highlighter.initialize())
            return null;
        const code = this.code();
        const before = resolveScope(code, false);
        const after = resolveScope(code, true);
        const dialect = this.dialect();
        return {
            before: highlighter.prepare(before, dialect),
            after: highlighter.prepare(after, dialect),
        };
    }
    get cursor() {
        this.cursorCache ?? (this.cursorCache = new CodeCursor(this));
        return this.cursorCache;
    }
    constructor(props) {
        super({
            fontFamily: 'monospace',
            ...props,
        });
        this.oldSelection = null;
        this.selectionProgress = createSignal(null);
        if (!useScene2D().experimentalFeatures) {
            throw new ExperimentalError('The Code node is an experimental feature');
        }
    }
    /**
     * Create a child code signal.
     *
     * @param initial - The initial code.
     */
    createSignal(initial) {
        return new CodeSignalContext(initial, this, this.highlighter, this.dialect).toSignal();
    }
    /**
     * Find all code ranges that match the given pattern.
     *
     * @param pattern - Either a string or a regular expression to match.
     */
    findAllRanges(pattern) {
        return findAllCodeRanges(this.parsed(), pattern);
    }
    /**
     * Find the first code range that matches the given pattern.
     *
     * @param pattern - Either a string or a regular expression to match.
     */
    findFirstRange(pattern) {
        return (findAllCodeRanges(this.parsed(), pattern, 1)[0] ?? [
            [0, 0],
            [0, 0],
        ]);
    }
    /**
     * Find the last code range that matches the given pattern.
     *
     * @param pattern - Either a string or a regular expression to match.
     */
    findLastRange(pattern) {
        return (findAllCodeRanges(this.parsed(), pattern).at(-1) ?? [
            [0, 0],
            [0, 0],
        ]);
    }
    /**
     * Return the bounding box of the given point (character) in the code.
     *
     * @remarks
     * The returned bound box is in local space of the `Code` node.
     *
     * @param point - The point to get the bounding box for.
     */
    getPointBbox(point) {
        const [line, column] = point;
        const drawingInfo = this.drawingInfo();
        let match;
        for (const info of drawingInfo.fragments) {
            if (info.cursor.y < line) {
                match = info;
                continue;
            }
            if (info.cursor.y === line && info.cursor.x < column) {
                match = info;
                continue;
            }
            break;
        }
        if (!match)
            return new BBox();
        const size = this.computedSize();
        return new BBox(match.position
            .sub(size.scale(0.5))
            .addX(match.characterSize.x * (column - match.cursor.x)), match.characterSize);
    }
    /**
     * Return bounding boxes of all characters in the selection.
     *
     * @remarks
     * The returned bound boxes are in local space of the `Code` node.
     * Each line of code has a separate bounding box.
     *
     * @param selection - The selection to get the bounding boxes for.
     */
    getSelectionBbox(selection) {
        const size = this.computedSize();
        const range = parseCodeSelection(selection);
        const drawingInfo = this.drawingInfo();
        const bboxes = [];
        let current = null;
        let line = 0;
        let column = 0;
        for (const info of drawingInfo.fragments) {
            if (info.cursor.y !== line) {
                line = info.cursor.y;
                if (current) {
                    bboxes.push(current);
                    current = null;
                }
            }
            column = info.cursor.x;
            for (let i = 0; i < info.text.length; i++) {
                if (isPointInCodeSelection([line, column], range)) {
                    const bbox = new BBox(info.position
                        .sub(size.scale(0.5))
                        .addX(info.characterSize.x * (column - info.cursor.x)), info.characterSize);
                    if (!current) {
                        current = bbox;
                    }
                    else {
                        current = current.union(bbox);
                    }
                }
                else if (current) {
                    bboxes.push(current);
                    current = null;
                }
                column++;
            }
        }
        if (current) {
            bboxes.push(current);
        }
        return bboxes;
    }
    drawingInfo() {
        this.requestFontUpdate();
        const context = this.cacheCanvas();
        const code = this.code();
        context.save();
        this.applyStyle(context);
        this.applyText(context);
        this.cursor.setupDraw(context);
        this.cursor.drawScope(code);
        const info = this.cursor.getDrawingInfo();
        context.restore();
        return info;
    }
    desiredSize() {
        this.requestFontUpdate();
        const context = this.cacheCanvas();
        const code = this.code();
        context.save();
        this.applyStyle(context);
        this.applyText(context);
        this.cursor.setupMeasure(context);
        this.cursor.measureSize(code);
        const size = this.cursor.getSize();
        context.restore();
        return size;
    }
    async draw(context) {
        this.requestFontUpdate();
        this.applyStyle(context);
        this.applyText(context);
        const size = this.computedSize();
        const drawingInfo = this.drawingInfo();
        context.save();
        context.translate(-size.width / 2, -size.height / 2 + drawingInfo.verticalOffset);
        const drawHooks = this.drawHooks();
        for (const info of drawingInfo.fragments) {
            context.save();
            context.globalAlpha *= info.alpha;
            drawHooks.token(context, info.text, info.position, info.fill, info.time);
            context.restore();
        }
        context.restore();
        await this.drawChildren(context);
    }
    applyText(context) {
        super.applyText(context);
        context.font = this.styles.font;
        context.textBaseline = 'top';
        if ('letterSpacing' in context) {
            context.letterSpacing = this.styles.letterSpacing;
        }
    }
    collectAsyncResources() {
        super.collectAsyncResources();
        this.highlighter()?.initialize();
    }
};
__decorate([
    initial(''),
    signal()
], Code.prototype, "dialect", void 0);
__decorate([
    initial(() => Code.defaultHighlighter),
    signal()
], Code.prototype, "highlighter", void 0);
__decorate([
    codeSignal()
], Code.prototype, "code", void 0);
__decorate([
    initial({
        token(ctx, text, position, color, selection) {
            ctx.fillStyle = color;
            ctx.globalAlpha *= map(0.2, 1, selection);
            ctx.fillText(text, position.x, position.y);
        },
    }),
    signal()
], Code.prototype, "drawHooks", void 0);
__decorate([
    initial(lines(0, Infinity)),
    parser(parseCodeSelection),
    signal()
], Code.prototype, "selection", void 0);
__decorate([
    computed()
], Code.prototype, "parsed", null);
__decorate([
    computed()
], Code.prototype, "highlighterCache", null);
__decorate([
    computed()
], Code.prototype, "drawingInfo", null);
__decorate([
    lazy(() => new LezerHighlighter(DefaultHighlightStyle))
], Code, "defaultHighlighter", void 0);
Code = __decorate([
    nodeName('CodeBlock')
], Code);
export { Code };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9Db2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFDTCxJQUFJLEVBQ0osWUFBWSxFQUNaLGlCQUFpQixFQUNqQixJQUFJLEVBQ0osR0FBRyxFQU9ILE1BQU0sR0FFUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0wsVUFBVSxFQU9WLFVBQVUsRUFDVixpQkFBaUIsRUFDakIscUJBQXFCLEVBQ3JCLGlCQUFpQixFQUNqQixzQkFBc0IsRUFDdEIsZ0JBQWdCLEVBQ2hCLEtBQUssRUFDTCxrQkFBa0IsRUFHbEIsWUFBWSxHQUNiLE1BQU0sU0FBUyxDQUFDO0FBQ2pCLE9BQU8sRUFBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRTFFLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDckMsT0FBTyxFQUFDLEtBQUssRUFBYSxNQUFNLFNBQVMsQ0FBQztBQXlEMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBDRztBQUVJLElBQU0sSUFBSSxHQUFWLE1BQU0sSUFBSyxTQUFRLEtBQUs7SUFDN0I7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLFlBQVksQ0FDeEIsT0FBMEIsRUFDMUIsV0FBMEMsRUFDMUMsT0FBNkI7UUFFN0IsT0FBTyxJQUFJLGlCQUFpQixDQUMxQixPQUFPLEVBQ1AsU0FBUyxFQUNULFdBQVcsRUFDWCxPQUFPLENBQ1IsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNmLENBQUM7SUE2SFMsQ0FBQyxjQUFjLENBQ3ZCLEtBQWtCLEVBQ2xCLFFBQWdCLEVBQ2hCLGNBQThCO1FBRTlCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JD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