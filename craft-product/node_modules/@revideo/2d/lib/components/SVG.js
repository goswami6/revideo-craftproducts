var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BBox, Matrix2D, Vector2, all, clampRemap, delay, easeInOutSine, isReactive, lazy, threadable, tween, useLogger, } from '@revideo/core';
import { computed, signal } from '../decorators';
import { applyTransformDiff, getTransformDiff } from '../utils/diff';
import { Circle } from './Circle';
import { Img } from './Img';
import { Layout } from './Layout';
import { Line } from './Line';
import { Node } from './Node';
import { Path } from './Path';
import { Rect } from './Rect';
import { Shape } from './Shape';
import { View2D } from './View2D';
/**
A Node for drawing and animating SVG images.

@remarks
If you're not interested in animating SVG, you can use {@link Img} instead.
 */
export class SVG extends Shape {
    constructor(props) {
        super(props);
        this.lastTweenTargetSrc = null;
        this.lastTweenTargetDocument = null;
        this.wrapper = new Node({});
        this.wrapper.children(this.documentNodes);
        this.wrapper.scale(this.wrapperScale);
        this.add(this.wrapper);
    }
    /**
     * Get all SVG nodes with the given id.
     * @param id - An id to query.
     */
    getChildrenById(id) {
        return this.document()
            .nodes.filter(node => node.id === id)
            .map(({ shape }) => shape);
    }
    desiredSize() {
        const docSize = this.document().size;
        const scale = this.calculateWrapperScale(docSize, super.desiredSize());
        return docSize.mul(scale);
    }
    getCurrentSize() {
        return {
            x: this.width.isInitial() ? null : this.width(),
            y: this.height.isInitial() ? null : this.height(),
        };
    }
    calculateWrapperScale(documentSize, parentSize) {
        const result = new Vector2(1, 1);
        if (parentSize.x && parentSize.y) {
            result.x = parentSize.x / documentSize.width;
            result.y = parentSize.y / documentSize.height;
        }
        else if (parentSize.x && !parentSize.y) {
            result.x = parentSize.x / documentSize.width;
            result.y = result.x;
        }
        else if (!parentSize.x && parentSize.y) {
            result.y = parentSize.y / documentSize.height;
            result.x = result.y;
        }
        return result;
    }
    /**
     * Convert `SVGDocumentData` to `SVGDocument`.
     * @param data - `SVGDocumentData` to convert.
     */
    buildDocument(data) {
        return {
            size: data.size,
            nodes: data.nodes.map(ch => this.buildShape(ch)),
        };
    }
    /**
     * Convert `SVGShapeData` to `SVGShape`.
     * @param data - `SVGShapeData` to convert.
     */
    buildShape({ id, type, props, children }) {
        return {
            id,
            shape: new type({
                children: children?.map(ch => this.buildShape(ch).shape),
                ...this.processElementStyle(props),
            }),
        };
    }
    /**
     * Convert an SVG string to `SVGDocument`.
     * @param svg - An SVG string to be parsed.
     */
    parseSVG(svg) {
        return this.buildDocument(SVG.parseSVGData(svg));
    }
    /**
     * Create a tweening list to tween between two SVG nodes.
     * @param from - The initial node,
     * @param to - The final node.
     * @param duration - The duration of the tween.
     * @param timing - The timing function.
     */
    *generateTransformer(from, to, duration, timing) {
        yield from.position(to.position(), duration, timing);
        yield from.scale(to.scale(), duration, timing);
        yield from.rotation(to.rotation(), duration, timing);
        if (from instanceof Path &&
            to instanceof Path &&
            from.data() !== to.data()) {
            yield from.data(to.data(), duration, timing);
        }
        if (from instanceof Layout && to instanceof Layout) {
            yield from.size(to.size(), duration, timing);
        }
        if (from instanceof Shape && to instanceof Shape) {
            yield from.fill(to.fill(), duration, timing);
            yield from.stroke(to.stroke(), duration, timing);
            yield from.lineWidth(to.lineWidth(), duration, timing);
        }
        const fromChildren = from.children();
        const toChildren = to.children();
        for (let i = 0; i < fromChildren.length; i++) {
            yield* this.generateTransformer(fromChildren[i], toChildren[i], duration, timing);
        }
    }
    *tweenSvg(value, time, timingFunction) {
        const newValue = isReactive(value) ? value() : value;
        const newSVG = this.parseSVG(newValue);
        const currentSVG = this.document();
        const diff = getTransformDiff(currentSVG.nodes, newSVG.nodes);
        this.lastTweenTargetSrc = newValue;
        this.lastTweenTargetDocument = newSVG;
        applyTransformDiff(currentSVG.nodes, diff, ({ shape, ...rest }) => ({
            ...rest,
            shape: shape.clone(),
        }));
        this.wrapper.children(currentSVG.nodes.map(shape => shape.shape));
        for (const item of currentSVG.nodes) {
            item.shape.parent(this.wrapper);
        }
        const beginning = 0.2;
        const ending = 0.8;
        const overlap = 0.15;
        const transformator = [];
        const transformatorTime = (ending - beginning) * time;
        const transformatorDelay = beginning * time;
        for (const item of diff.transformed) {
            transformator.push(...this.generateTransformer(item.from.current.shape, item.to.current.shape, transformatorTime, timingFunction));
        }
        const autoWidth = this.width.isInitial();
        const autoHeight = this.height.isInitial();
        this.wrapper.scale(this.calculateWrapperScale(currentSVG.size, this.getCurrentSize()));
        const baseTween = tween(time, value => {
            const progress = timingFunction(value);
            const remapped = clampRemap(beginning, ending, 0, 1, progress);
            const scale = this.wrapper.scale();
            if (autoWidth) {
                this.width(easeInOutSine(remapped, currentSVG.size.x, newSVG.size.x) * scale.x);
            }
            if (autoHeight) {
                this.height(easeInOutSine(remapped, currentSVG.size.y, newSVG.size.y) * scale.y);
            }
            const deletedOpacity = clampRemap(0, beginning + overlap, 1, 0, progress);
            for (const { current } of diff.deleted) {
                current.shape.opacity(deletedOpacity);
            }
            const insertedOpacity = clampRemap(ending - overlap, 1, 0, 1, progress);
            for (const { current } of diff.inserted) {
                current.shape.opacity(insertedOpacity);
            }
        }, () => {
            this.wrapper.children(this.documentNodes);
            if (autoWidth)
                this.width.reset();
            if (autoHeight)
                this.height.reset();
            for (const { current } of diff.deleted)
                current.shape.dispose();
            for (const { from } of diff.transformed) {
                from.current.shape.dispose();
            }
            this.wrapper.scale(this.wrapperScale);
        });
        yield* all(this.wrapper.scale(this.calculateWrapperScale(newSVG.size, this.getCurrentSize()), time, timingFunction), baseTween, delay(transformatorDelay, all(...transformator)));
    }
    wrapperScale() {
        return this.calculateWrapperScale(this.document().size, this.getCurrentSize());
    }
    /**
     * Get the current `SVGDocument`.
     */
    document() {
        try {
            const src = this.svg();
            if (this.lastTweenTargetDocument && src === this.lastTweenTargetSrc) {
                return this.lastTweenTargetDocument;
            }
            return this.parseSVG(src);
        }
        finally {
            this.lastTweenTargetSrc = null;
            this.lastTweenTargetDocument = null;
        }
    }
    /**
     * Get current document nodes.
     */
    documentNodes() {
        return this.document().nodes.map(node => node.shape);
    }
    /**
     * Convert SVG colors in Shape properties to Motion Canvas colors.
     * @param param - Shape properties.
     * @returns Converted Shape properties.
     */
    processElementStyle({ fill, stroke, ...rest }) {
        return {
            fill: fill === 'currentColor' ? this.fill : SVG.processSVGColor(fill),
            stroke: stroke === 'currentColor' ? this.stroke : SVG.processSVGColor(stroke),
            ...rest,
        };
    }
    /**
     * Parse an SVG string as `SVGDocumentData`.
     * @param svg - And SVG string to be parsed.
     * @returns `SVGDocumentData` that can be used to build SVGDocument.
     */
    static parseSVGData(svg) {
        const cached = SVG.svgNodesPool[svg];
        if (cached && (cached.size.x > 0 || cached.size.y > 0))
            return cached;
        SVG.containerElement.innerHTML = svg;
        const svgRoot = SVG.containerElement.querySelector('svg');
        if (!svgRoot) {
            useLogger().error({
                message: 'Invalid SVG',
                object: svg,
            });
            return {
                size: new Vector2(0, 0),
                nodes: [],
            };
        }
        let viewBox = new BBox();
        let size = new Vector2();
        const hasViewBox = svgRoot.hasAttribute('viewBox');
        const hasSize = svgRoot.hasAttribute('width') || svgRoot.hasAttribute('height');
        if (hasViewBox) {
            const { x, y, width, height } = svgRoot.viewBox.baseVal;
            viewBox = new BBox(x, y, width, height);
            if (!hasSize)
                size = viewBox.size;
        }
        if (hasSize) {
            size = new Vector2(svgRoot.width.baseVal.value, svgRoot.height.baseVal.value);
            if (!hasViewBox)
                viewBox = new BBox(0, 0, size.width, size.height);
        }
        if (!hasViewBox && !hasSize) {
            viewBox = new BBox(svgRoot.getBBox());
            size = viewBox.size;
        }
        const scale = size.div(viewBox.size);
        const center = viewBox.center;
        const rootTransform = new DOMMatrix()
            .scaleSelf(scale.x, scale.y)
            .translateSelf(-center.x, -center.y);
        const nodes = Array.from(SVG.extractGroupNodes(svgRoot, svgRoot, rootTransform, {}));
        const builder = {
            size,
            nodes,
        };
        SVG.svgNodesPool[svg] = builder;
        return builder;
    }
    /**
     * Get position, rotation and scale from Matrix transformation as Shape properties
     * @param transform - Matrix transformation
     * @returns MotionCanvas Shape properties
     */
    static getMatrixTransformation(transform) {
        const matrix2 = new Matrix2D(transform);
        const position = matrix2.translation;
        const rotation = matrix2.rotation;
        // matrix.scaling can give incorrect result when matrix contain skew operation
        const scale = {
            x: matrix2.x.magnitude,
            y: matrix2.y.magnitude,
        };
        if (matrix2.determinant < 0) {
            if (matrix2.values[0] < matrix2.values[3])
                scale.x = -scale.x;
            else
                scale.y = -scale.y;
        }
        return {
            position,
            rotation,
            scale,
        };
    }
    /**
     * Convert an SVG color into a Motion Canvas color.
     * @param color - SVG color.
     * @returns Motion Canvas color.
     */
    static processSVGColor(color) {
        if (color === 'transparent' || color === 'none') {
            return null;
        }
        return color;
    }
    /**
     * Get the final transformation matrix for the given SVG element.
     * @param element - SVG element.
     * @param parentTransform - The transformation matrix of the parent.
     */
    static getElementTransformation(element, parentTransform) {
        const transform = element.transform.baseVal.consolidate();
        const transformMatrix = (transform ? parentTransform.multiply(transform.matrix) : parentTransform).translate(SVG.parseNumberAttribute(element, 'x'), SVG.parseNumberAttribute(element, 'y'));
        return transformMatrix;
    }
    static parseLineCap(name) {
        if (!name)
            return null;
        if (name === 'butt' || name === 'round' || name === 'square')
            return name;
        useLogger().warn(`SVG: invalid line cap "${name}"`);
        return null;
    }
    static parseLineJoin(name) {
        if (!name)
            return null;
        if (name === 'bevel' || name === 'miter' || name === 'round')
            return name;
        if (name === 'arcs' || name === 'miter-clip') {
            useLogger().warn(`SVG: line join is not supported "${name}"`);
        }
        else {
            useLogger().warn(`SVG: invalid line join "${name}"`);
        }
        return null;
    }
    static parseLineDash(value) {
        if (!value)
            return null;
        const list = value.split(/,|\s+/);
        if (list.findIndex(str => str.endsWith('%')) > 0) {
            useLogger().warn(`SVG: percentage line dash are ignored`);
            return null;
        }
        return list.map(str => parseFloat(str));
    }
    static parseDashOffset(value) {
        if (!value)
            return null;
        const trimmed = value.trim();
        if (trimmed.endsWith('%')) {
            useLogger().warn(`SVG: percentage line dash offset are ignored`);
        }
        return parseFloat(trimmed);
    }
    static parseOpacity(value) {
        if (!value)
            return null;
        if (value.endsWith('%'))
            return parseFloat(value) / 100;
        return parseFloat(value);
    }
    /**
     * Convert the SVG element's style to a Motion Canvas Shape properties.
     * @param element - An SVG element whose style should be converted.
     * @param inheritedStyle - The parent style that should be inherited.
     */
    static getElementStyle(element, inheritedStyle) {
        return {
            fill: element.getAttribute('fill') ?? inheritedStyle.fill,
            stroke: element.getAttribute('stroke') ?? inheritedStyle.stroke,
            lineWidth: element.hasAttribute('stroke-width')
                ? parseFloat(element.getAttribute('stroke-width'))
                : inheritedStyle.lineWidth,
            lineCap: this.parseLineCap(element.getAttribute('stroke-linecap')) ??
                inheritedStyle.lineCap,
            lineJoin: this.parseLineJoin(element.getAttribute('stroke-linejoin')) ??
                inheritedStyle.lineJoin,
            lineDash: this.parseLineDash(element.getAttribute('stroke-dasharray')) ??
                inheritedStyle.lineDash,
            lineDashOffset: this.parseDashOffset(element.getAttribute('stroke-dashoffset')) ??
                inheritedStyle.lineDashOffset,
            opacity: this.parseOpacity(element.getAttribute('opacity')) ??
                inheritedStyle.opacity,
            layout: false,
        };
    }
    /**
     * Extract `SVGShapeData` list from the SVG element's children.
     * This will not extract the current element's shape.
     * @param element - An element whose children will be extracted.
     * @param svgRoot - The SVG root ("svg" tag) of the element.
     * @param parentTransform - The transformation matrix applied to the parent.
     * @param inheritedStyle - The style of the current SVG `element` that the children should inherit.
     */
    static *extractGroupNodes(element, svgRoot, parentTransform, inheritedStyle) {
        for (const child of element.children) {
            if (!(child instanceof SVGGraphicsElement))
                continue;
            yield* this.extractElementNodes(child, svgRoot, parentTransform, inheritedStyle);
        }
    }
    /**
     * Parse a number from an SVG element attribute.
     * @param element - SVG element whose attribute will be parsed.
     * @param name - The name of the attribute to parse.
     * @returns a parsed number or `0` if the attribute is not defined.
     */
    static parseNumberAttribute(element, name) {
        return parseFloat(element.getAttribute(name) ?? '0');
    }
    /**
     * Extract `SVGShapeData` list from the SVG element.
     * This will also recursively extract shapes from its children.
     * @param child - An SVG element to extract.
     * @param svgRoot - The SVG root ("svg" tag) of the element.
     * @param parentTransform - The transformation matrix applied to the parent.
     * @param inheritedStyle - The style of the parent SVG element that the element should inherit.
     */
    static *extractElementNodes(child, svgRoot, parentTransform, inheritedStyle) {
        const transformMatrix = SVG.getElementTransformation(child, parentTransform);
        const style = SVG.getElementStyle(child, inheritedStyle);
        const id = child.id ?? '';
        if (child.tagName === 'g') {
            yield* SVG.extractGroupNodes(child, svgRoot, transformMatrix, style);
        }
        else if (child.tagName === 'use') {
            const hrefElement = svgRoot.querySelector(child.href.baseVal);
            if (!(hrefElement instanceof SVGGraphicsElement)) {
                useLogger().warn(`invalid SVG use tag. element "${child.outerHTML}"`);
                return;
            }
            yield* SVG.extractElementNodes(hrefElement, svgRoot, transformMatrix, inheritedStyle);
        }
        else if (child.tagName === 'path') {
            const data = child.getAttribute('d');
            if (!data) {
                useLogger().warn('blank path data at ' + child.id);
                return;
            }
            const transformation = transformMatrix;
            yield {
                id: id || 'path',
                type: Path,
                props: {
                    data,
                    tweenAlignPath: true,
                    ...SVG.getMatrixTransformation(transformation),
                    ...style,
                },
            };
        }
        else if (child.tagName === 'rect') {
            const width = SVG.parseNumberAttribute(child, 'width');
            const height = SVG.parseNumberAttribute(child, 'height');
            const rx = SVG.parseNumberAttribute(child, 'rx');
            const ry = SVG.parseNumberAttribute(child, 'ry');
            const bbox = new BBox(0, 0, width, height);
            const center = bbox.center;
            const transformation = transformMatrix.translate(center.x, center.y);
            yield {
                id: id || 'rect',
                type: Rect,
                props: {
                    width,
                    height,
                    radius: [rx, ry],
                    ...SVG.getMatrixTransformation(transformation),
                    ...style,
                },
            };
        }
        else if (['circle', 'ellipse'].includes(child.tagName)) {
            const cx = SVG.parseNumberAttribute(child, 'cx');
            const cy = SVG.parseNumberAttribute(child, 'cy');
            const size = child.tagName === 'circle'
                ? SVG.parseNumberAttribute(child, 'r') * 2
                : [
                    SVG.parseNumberAttribute(child, 'rx') * 2,
                    SVG.parseNumberAttribute(child, 'ry') * 2,
                ];
            const transformation = transformMatrix.translate(cx, cy);
            yield {
                id: id || child.tagName,
                type: Circle,
                props: {
                    size,
                    ...style,
                    ...SVG.getMatrixTransformation(transformation),
                },
            };
        }
        else if (['line', 'polyline', 'polygon'].includes(child.tagName)) {
            const numbers = child.tagName === 'line'
                ? ['x1', 'y1', 'x2', 'y2'].map(attr => SVG.parseNumberAttribute(child, attr))
                : child
                    .getAttribute('points')
                    .match(/-?[\d.e+-]+/g)
                    .map(value => parseFloat(value));
            const points = numbers.reduce((accum, current) => {
                let last = accum.at(-1);
                if (!last || last.length === 2) {
                    last = [];
                    accum.push(last);
                }
                last.push(current);
                return accum;
            }, []);
            if (child.tagName === 'polygon')
                points.push(points[0]);
            yield {
                id: id || child.tagName,
                type: Line,
                props: {
                    points,
                    ...style,
                    ...SVG.getMatrixTransformation(transformMatrix),
                },
            };
        }
        else if (child.tagName === 'image') {
            const x = SVG.parseNumberAttribute(child, 'x');
            const y = SVG.parseNumberAttribute(child, 'y');
            const width = SVG.parseNumberAttribute(child, 'width');
            const height = SVG.parseNumberAttribute(child, 'height');
            const href = child.getAttribute('href') ?? '';
            const bbox = new BBox(x, y, width, height);
            const center = bbox.center;
            const transformation = transformMatrix.translate(center.x, center.y);
            yield {
                id: id || child.tagName,
                type: Img,
                props: {
                    src: href,
                    ...style,
                    ...SVG.getMatrixTransformation(transformation),
                },
            };
        }
    }
}
SVG.svgNodesPool = {};
__decorate([
    signal()
], SVG.prototype, "svg", void 0);
__decorate([
    threadable()
], SVG.prototype, "tweenSvg", null);
__decorate([
    computed()
], SVG.prototype, "wrapperScale", null);
__decorate([
    computed()
], SVG.prototype, "document", null);
__decorate([
    computed()
], SVG.prototype, "documentNodes", null);
__decorate([
    lazy(() => {
        const element = document.createElement('div');
        View2D.shadowRoot.appendChild(element);
        return element;
    })
], SVG, "containerElement", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU1ZHLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9jb21wb25lbnRzL1NWRy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQ0wsSUFBSSxFQUNKLFFBQVEsRUFPUixPQUFPLEVBQ1AsR0FBRyxFQUNILFVBQVUsRUFDVixLQUFLLEVBQ0wsYUFBYSxFQUNiLFVBQVUsRUFDVixJQUFJLEVBQ0osVUFBVSxFQUNWLEtBQUssRUFDTCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFL0MsT0FBTyxFQUFDLGtCQUFrQixFQUFFLGdCQUFnQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ25FLE9BQU8sRUFBQyxNQUFNLEVBQWMsTUFBTSxVQUFVLENBQUM7QUFDN0MsT0FBTyxFQUFDLEdBQUcsRUFBVyxNQUFNLE9BQU8sQ0FBQztBQUNwQyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ2hDLE9BQU8sRUFBQyxJQUFJLEVBQVksTUFBTSxRQUFRLENBQUM7QUFDdkMsT0FBTyxFQUFDLElBQUksRUFBWSxNQUFNLFFBQVEsQ0FBQztBQUN2QyxPQUFPLEVBQUMsSUFBSSxFQUFZLE1BQU0sUUFBUSxDQUFDO0FBQ3ZDLE9BQU8sRUFBQyxJQUFJLEVBQVksTUFBTSxRQUFRLENBQUM7QUFDdkMsT0FBTyxFQUFDLEtBQUssRUFBYSxNQUFNLFNBQVMsQ0FBQztBQUMxQyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBOENoQzs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxHQUFJLFNBQVEsS0FBSztJQXVCNUIsWUFBbUIsS0FBZTtRQUNoQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFKUCx1QkFBa0IsR0FBa0IsSUFBSSxDQUFDO1FBQ3pDLDRCQUF1QixHQUF1QixJQUFJLENBQUM7UUFJ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