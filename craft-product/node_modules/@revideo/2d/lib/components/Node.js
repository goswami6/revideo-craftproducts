var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Node_1;
import { BBox, DependencyContext, UNIFORM_DESTINATION_MATRIX, UNIFORM_SOURCE_MATRIX, UNIFORM_TIME, Vector2, all, clamp, createSignal, easeInOutCubic, isReactive, modify, threadable, transformAngle, transformScalar, unwrap, useLogger, } from '@revideo/core';
import { NODE_NAME, cloneable, colorSignal, computed, getPropertiesOf, initial, initializeSignals, inspectable, nodeName, parser, signal, vector2Signal, wrapper, } from '../decorators';
import { filtersSignal } from '../decorators/filtersSignal';
import { spacingSignal } from '../decorators/spacingSignal';
import { parseShader, } from '../partials/ShaderConfig';
import { useScene2D } from '../scenes/useScene2D';
import { drawLine } from '../utils';
let Node = Node_1 = class Node {
    get x() {
        return this.position.x;
    }
    get y() {
        return this.position.y;
    }
    getAbsolutePosition() {
        const matrix = this.localToWorld();
        return new Vector2(matrix.m41, matrix.m42);
    }
    setAbsolutePosition(value) {
        this.position(modify(value, unwrapped => new Vector2(unwrapped).transformAsPoint(this.worldToParent())));
    }
    getAbsoluteRotation() {
        const matrix = this.localToWorld();
        return Vector2.degrees(matrix.m11, matrix.m12);
    }
    setAbsoluteRotation(value) {
        this.rotation(modify(value, unwrapped => transformAngle(unwrapped, this.worldToParent())));
    }
    getAbsoluteScale() {
        const matrix = this.localToWorld();
        return new Vector2(Vector2.magnitude(matrix.m11, matrix.m12), Vector2.magnitude(matrix.m21, matrix.m22));
    }
    setAbsoluteScale(value) {
        this.scale(modify(value, unwrapped => this.getRelativeScale(new Vector2(unwrapped))));
    }
    getRelativeScale(scale) {
        const parentScale = this.parent()?.absoluteScale() ?? Vector2.one;
        return scale.div(parentScale);
    }
    *tweenCompositeOperation(value, time, timingFunction) {
        const nextValue = unwrap(value);
        if (nextValue === 'source-over') {
            yield* this.compositeOverride(1, time, timingFunction);
            this.compositeOverride(0);
            this.compositeOperation(nextValue);
        }
        else {
            this.compositeOperation(nextValue);
            this.compositeOverride(1);
            yield* this.compositeOverride(0, time, timingFunction);
        }
    }
    absoluteOpacity() {
        return (this.parent()?.absoluteOpacity() ?? 1) * this.opacity();
    }
    hasFilters() {
        return !!this.filters().find(filter => filter.isActive());
    }
    hasShadow() {
        return (!!this.shadowColor() &&
            (this.shadowBlur() > 0 ||
                this.shadowOffset.x() !== 0 ||
                this.shadowOffset.y() !== 0));
    }
    filterString() {
        let filters = '';
        const matrix = this.compositeToWorld();
        for (const filter of this.filters()) {
            if (filter.isActive()) {
                filters += ' ' + filter.serialize(matrix);
            }
        }
        return filters;
    }
    getSpawner() {
        return this.children();
    }
    setSpawner(value) {
        this.children(value);
    }
    setChildren(value) {
        if (this.children.context.raw() === value) {
            return;
        }
        this.children.context.setter(value);
        if (!isReactive(value)) {
            this.spawnChildren(false, value);
        }
        else if (!this.hasSpawnedChildren) {
            for (const oldChild of this.realChildren) {
                oldChild.parent(null);
            }
        }
    }
    getChildren() {
        this.children.context.getter();
        return this.spawnedChildren();
    }
    spawnedChildren() {
        const children = this.children.context.getter();
        if (isReactive(this.children.context.raw())) {
            this.spawnChildren(true, children);
        }
        return this.realChildren;
    }
    sortedChildren() {
        return [...this.children()].sort((a, b) => Math.sign(a.zIndex() - b.zIndex()));
    }
    constructor({ children, spawner, key, ...rest }) {
        this.compositeOverride = createSignal(0);
        this.stateStack = [];
        this.realChildren = [];
        this.hasSpawnedChildren = false;
        this.parent = createSignal(null);
        this.properties = getPropertiesOf(this);
        const scene = useScene2D();
        [this.key, this.unregister] = scene.registerNode(this, key);
        this.view2D = scene.getView();
        this.creationStack = new Error().stack;
        initializeSignals(this, rest);
        if (spawner) {
            useLogger().warn({
                message: 'Node.spawner() has been deprecated.',
                remarks: 'Use <code>Node.children()</code> instead.',
                inspect: this.key,
                stack: new Error().stack,
            });
        }
        this.children(spawner ?? children);
    }
    /**
     * Get the local-to-world matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from local space of this node to world
     * space.
     *
     * @example
     * Calculate the absolute position of a point located 200 pixels to the right
     * of the node:
     * ```ts
     * const local = new Vector2(0, 200);
     * const world = local.transformAsPoint(node.localToWorld());
     * ```
     */
    localToWorld() {
        const parent = this.parent();
        return parent
            ? parent.localToWorld().multiply(this.localToParent())
            : this.localToParent();
    }
    /**
     * Get the world-to-local matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from world space to local space of this
     * node.
     *
     * @example
     * Calculate the position relative to this node for a point located in the
     * top-left corner of the screen:
     * ```ts
     * const world = new Vector2(0, 0);
     * const local = world.transformAsPoint(node.worldToLocal());
     * ```
     */
    worldToLocal() {
        return this.localToWorld().inverse();
    }
    /**
     * Get the world-to-parent matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from world space to local space of this
     * node's parent.
     */
    worldToParent() {
        return this.parent()?.worldToLocal() ?? new DOMMatrix();
    }
    /**
     * Get the local-to-parent matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from local space of this node to local space
     * of this node's parent.
     */
    localToParent() {
        const matrix = new DOMMatrix();
        matrix.translateSelf(this.x(), this.y());
        matrix.rotateSelf(0, 0, this.rotation());
        matrix.scaleSelf(this.scale.x(), this.scale.y());
        matrix.skewXSelf(this.skew.x());
        matrix.skewYSelf(this.skew.y());
        return matrix;
    }
    /**
     * A matrix mapping composite space to world space.
     *
     * @remarks
     * Certain effects such as blur and shadows ignore the current transformation.
     * This matrix can be used to transform their parameters so that the effect
     * appears relative to the closest composite root.
     */
    compositeToWorld() {
        return this.compositeRoot()?.localToWorld() ?? new DOMMatrix();
    }
    compositeRoot() {
        if (this.composite()) {
            return this;
        }
        return this.parent()?.compositeRoot() ?? null;
    }
    compositeToLocal() {
        const root = this.compositeRoot();
        if (root) {
            const worldToLocal = this.worldToLocal();
            worldToLocal.m44 = 1;
            return root.localToWorld().multiply(worldToLocal);
        }
        return new DOMMatrix();
    }
    view() {
        return this.view2D;
    }
    /**
     * Add the given node(s) as the children of this node.
     *
     * @remarks
     * The nodes will be appended at the end of the children list.
     *
     * @example
     * ```tsx
     * const node = <Layout />;
     * node.add(<Rect />);
     * node.add(<Circle />);
     * ```
     * Result:
     * ```mermaid
     * graph TD;
     *   layout([Layout])
     *   circle([Circle])
     *   rect([Rect])
     *     layout-->rect;
     *     layout-->circle;
     * ```
     *
     * @param node - A node or an array of nodes to append.
     */
    add(node) {
        return this.insert(node, Infinity);
    }
    /**
     * Insert the given node(s) at the specified index in the children list.
     *
     * @example
     * ```tsx
     * const node = (
     *   <Layout>
     *     <Rect />
     *     <Circle />
     *   </Layout>
     * );
     *
     * node.insert(<Txt />, 1);
     * ```
     *
     * Result:
     * ```mermaid
     * graph TD;
     *   layout([Layout])
     *   circle([Circle])
     *   text([Text])
     *   rect([Rect])
     *     layout-->rect;
     *     layout-->text;
     *     layout-->circle;
     * ```
     *
     * @param node - A node or an array of nodes to insert.
     * @param index - An index at which to insert the node(s).
     */
    insert(node, index = 0) {
        const array = Array.isArray(node) ? node : [node];
        if (array.length === 0) {
            return this;
        }
        const children = this.children();
        const newChildren = children.slice(0, index);
        for (const node of array) {
            if (node instanceof Node_1) {
                newChildren.push(node);
                node.remove();
                node.parent(this);
            }
        }
        newChildren.push(...children.slice(index));
        this.setParsedChildren(newChildren);
        return this;
    }
    /**
     * Remove this node from the tree.
     */
    remove() {
        const current = this.parent();
        if (current === null) {
            return this;
        }
        current.removeChild(this);
        this.parent(null);
        return this;
    }
    /**
     * Rearrange this node in relation to its siblings.
     *
     * @remarks
     * Children are rendered starting from the beginning of the children list.
     * We can change the rendering order by rearranging said list.
     *
     * A positive `by` arguments move the node up (it will be rendered on top of
     * the elements it has passed). Negative values move it down.
     *
     * @param by - Number of places by which the node should be moved.
     */
    move(by = 1) {
        const parent = this.parent();
        if (by === 0 || !parent) {
            return this;
        }
        const children = parent.children();
        const newChildren = [];
        if (by > 0) {
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child === this) {
                    const target = i + by;
                    for (; i < target && i + 1 < children.length; i++) {
                        newChildren[i] = children[i + 1];
                    }
                }
                newChildren[i] = child;
            }
        }
        else {
            for (let i = children.length - 1; i >= 0; i--) {
                const child = children[i];
                if (child === this) {
                    const target = i + by;
                    for (; i > target && i > 0; i--) {
                        newChildren[i] = children[i - 1];
                    }
                }
                newChildren[i] = child;
            }
        }
        parent.setParsedChildren(newChildren);
        return this;
    }
    /**
     * Move the node up in relation to its siblings.
     *
     * @remarks
     * The node will exchange places with the sibling right above it (if any) and
     * from then on will be rendered on top of it.
     */
    moveUp() {
        return this.move(1);
    }
    /**
     * Move the node down in relation to its siblings.
     *
     * @remarks
     * The node will exchange places with the sibling right below it (if any) and
     * from then on will be rendered under it.
     */
    moveDown() {
        return this.move(-1);
    }
    /**
     * Move the node to the top in relation to its siblings.
     *
     * @remarks
     * The node will be placed at the end of the children list and from then on
     * will be rendered on top of all of its siblings.
     */
    moveToTop() {
        return this.move(Infinity);
    }
    /**
     * Move the node to the bottom in relation to its siblings.
     *
     * @remarks
     * The node will be placed at the beginning of the children list and from then
     * on will be rendered below all of its siblings.
     */
    moveToBottom() {
        return this.move(-Infinity);
    }
    /**
     * Move the node to the provided position relative to its siblings.
     *
     * @remarks
     * If the node is getting moved to a lower position, it will be placed below
     * the sibling that's currently at the provided index (if any).
     * If the node is getting moved to a higher position, it will be placed above
     * the sibling that's currently at the provided index (if any).
     *
     * @param index - The index to move the node to.
     */
    moveTo(index) {
        const parent = this.parent();
        if (!parent) {
            return this;
        }
        const currentIndex = parent.children().indexOf(this);
        const by = index - currentIndex;
        return this.move(by);
    }
    /**
     * Move the node below the provided node in the parent's layout.
     *
     * @remarks
     * The node will be moved below the provided node and from then on will be
     * rendered below it. By default, if the node is already positioned lower than
     * the sibling node, it will not get moved.
     *
     * @param node - The sibling node below which to move.
     * @param directlyBelow - Whether the node should be positioned directly below
     *                        the sibling. When true, will move the node even if
     *                        it is already positioned below the sibling.
     */
    moveBelow(node, directlyBelow = false) {
        const parent = this.parent();
        if (!parent) {
            return this;
        }
        if (node.parent() !== parent) {
            useLogger().error("Cannot position nodes relative to each other if they don't belong to the same parent.");
            return this;
        }
        const children = parent.children();
        const ownIndex = children.indexOf(this);
        const otherIndex = children.indexOf(node);
        if (!directlyBelow && ownIndex < otherIndex) {
            // Nothing to do if the node is already positioned below the target node.
            // We could move the node so it's directly below the sibling node, but
            // that might suddenly move it on top of other nodes. This is likely
            // not what the user wanted to happen when calling this method.
            return this;
        }
        const by = otherIndex - ownIndex - 1;
        return this.move(by);
    }
    /**
     * Move the node above the provided node in the parent's layout.
     *
     * @remarks
     * The node will be moved above the provided node and from then on will be
     * rendered on top of it. By default, if the node is already positioned
     * higher than the sibling node, it will not get moved.
     *
     * @param node - The sibling node below which to move.
     * @param directlyAbove - Whether the node should be positioned directly above the
     *                        sibling. When true, will move the node even if it is
     *                        already positioned above the sibling.
     */
    moveAbove(node, directlyAbove = false) {
        const parent = this.parent();
        if (!parent) {
            return this;
        }
        if (node.parent() !== parent) {
            useLogger().error("Cannot position nodes relative to each other if they don't belong to the same parent.");
            return this;
        }
        const children = parent.children();
        const ownIndex = children.indexOf(this);
        const otherIndex = children.indexOf(node);
        if (!directlyAbove && ownIndex > otherIndex) {
            // Nothing to do if the node is already positioned above the target node.
            // We could move the node so it's directly above the sibling node, but
            // that might suddenly move it below other nodes. This is likely not what
            // the user wanted to happen when calling this method.
            return this;
        }
        const by = otherIndex - ownIndex + 1;
        return this.move(by);
    }
    /**
     * Change the parent of this node while keeping the absolute transform.
     *
     * @remarks
     * After performing this operation, the node will stay in the same place
     * visually, but its parent will be changed.
     *
     * @param newParent - The new parent of this node.
     */
    reparent(newParent) {
        const position = this.absolutePosition();
        const rotation = this.absoluteRotation();
        const scale = this.absoluteScale();
        newParent.add(this);
        this.absolutePosition(position);
        this.absoluteRotation(rotation);
        this.absoluteScale(scale);
    }
    /**
     * Remove all children of this node.
     */
    removeChildren() {
        for (const oldChild of this.realChildren) {
            oldChild.parent(null);
        }
        this.setParsedChildren([]);
    }
    /**
     * Get the current children of this node.
     *
     * @remarks
     * Unlike {@link children}, this method does not have any side effects.
     * It does not register the `children` signal as a dependency, and it does not
     * spawn any children. It can be used to safely retrieve the current state of
     * the scene graph for debugging purposes.
     */
    peekChildren() {
        return this.realChildren;
    }
    findAll(predicate) {
        const result = [];
        const queue = this.reversedChildren();
        while (queue.length > 0) {
            const node = queue.pop();
            if (predicate(node)) {
                result.push(node);
            }
            const children = node.children();
            for (let i = children.length - 1; i >= 0; i--) {
                queue.push(children[i]);
            }
        }
        return result;
    }
    findFirst(predicate) {
        const queue = this.reversedChildren();
        while (queue.length > 0) {
            const node = queue.pop();
            if (predicate(node)) {
                return node;
            }
            const children = node.children();
            for (let i = children.length - 1; i >= 0; i--) {
                queue.push(children[i]);
            }
        }
        return null;
    }
    findLast(predicate) {
        const search = [];
        const queue = this.reversedChildren();
        while (queue.length > 0) {
            const node = queue.pop();
            search.push(node);
            const children = node.children();
            for (let i = children.length - 1; i >= 0; i--) {
                queue.push(children[i]);
            }
        }
        while (search.length > 0) {
            const node = search.pop();
            if (predicate(node)) {
                return node;
            }
        }
        return null;
    }
    findAncestor(predicate) {
        let parent = this.parent();
        while (parent) {
            if (predicate(parent)) {
                return parent;
            }
            parent = parent.parent();
        }
        return null;
    }
    /**
     * Get the nth children cast to the specified type.
     *
     * @param index - The index of the child to retrieve.
     */
    childAs(index) {
        return this.children()[index] ?? null;
    }
    /**
     * Get the children array cast to the specified type.
     */
    childrenAs() {
        return this.children();
    }
    /**
     * Get the parent cast to the specified type.
     */
    parentAs() {
        return this.parent() ?? null;
    }
    /**
     * Prepare this node to be disposed of.
     *
     * @remarks
     * This method is called automatically when a scene is refreshed. It will
     * be called even if the node is not currently attached to the tree.
     *
     * The goal of this method is to clean any external references to allow the
     * node to be garbage collected.
     */
    dispose() {
        if (!this.unregister) {
            return;
        }
        this.stateStack = [];
        this.unregister();
        this.unregister = null;
        for (const { signal } of this) {
            signal?.context.dispose();
        }
        for (const child of this.realChildren) {
            child.dispose();
        }
    }
    /**
     * Create a copy of this node.
     *
     * @param customProps - Properties to override.
     */
    clone(customProps = {}) {
        const props = { ...customProps };
        if (isReactive(this.children.context.raw())) {
            props.children ?? (props.children = this.children.context.raw());
        }
        else if (this.children().length > 0) {
            props.children ?? (props.children = this.children().map(child => child.clone()));
        }
        for (const { key, meta, signal } of this) {
            if (!meta.cloneable || key in props)
                continue;
            if (meta.compound) {
                for (const [key, property] of meta.compoundEntries) {
                    if (property in props)
                        continue;
                    const component = signal[key];
                    if (!component.context.isInitial()) {
                        props[property] = component.context.raw();
                    }
                }
            }
            else if (!signal.context.isInitial()) {
                props[key] = signal.context.raw();
            }
        }
        return this.instantiate(props);
    }
    /**
     * Create a copy of this node.
     *
     * @remarks
     * Unlike {@link clone}, a snapshot clone calculates any reactive properties
     * at the moment of cloning and passes the raw values to the copy.
     *
     * @param customProps - Properties to override.
     */
    snapshotClone(customProps = {}) {
        const props = {
            ...this.getState(),
            ...customProps,
        };
        if (this.children().length > 0) {
            props.children ?? (props.children = this.children().map(child => child.snapshotClone()));
        }
        return this.instantiate(props);
    }
    /**
     * Create a reactive copy of this node.
     *
     * @remarks
     * A reactive copy has all its properties dynamically updated to match the
     * source node.
     *
     * @param customProps - Properties to override.
     */
    reactiveClone(customProps = {}) {
        const props = { ...customProps };
        if (this.children().length > 0) {
            props.children ?? (props.children = this.children().map(child => child.reactiveClone()));
        }
        for (const { key, meta, signal } of this) {
            if (!meta.cloneable || key in props)
                continue;
            props[key] = () => signal();
        }
        return this.instantiate(props);
    }
    /**
     * Create an instance of this node's class.
     *
     * @param props - Properties to pass to the constructor.
     */
    instantiate(props = {}) {
        return new this.constructor(props);
    }
    /**
     * Set the children without parsing them.
     *
     * @remarks
     * This method assumes that the caller took care of parsing the children and
     * updating the hierarchy.
     *
     * @param value - The children to set.
     */
    setParsedChildren(value) {
        this.children.context.setter(value);
        this.realChildren = value;
    }
    spawnChildren(reactive, children) {
        const parsedChildren = this.parseChildren(children);
        const keep = new Set();
        for (const newChild of parsedChildren) {
            const current = newChild.parent.context.raw();
            if (current && current !== this) {
                current.removeChild(newChild);
            }
            keep.add(newChild.key);
            newChild.parent(this);
        }
        for (const oldChild of this.realChildren) {
            if (!keep.has(oldChild.key)) {
                oldChild.parent(null);
            }
        }
        this.hasSpawnedChildren = reactive;
        this.realChildren = parsedChildren;
    }
    /**
     * Parse any `ComponentChildren` into an array of nodes.
     *
     * @param children - The children to parse.
     */
    parseChildren(children) {
        const result = [];
        const array = Array.isArray(children) ? children : [children];
        for (const child of array) {
            if (child instanceof Node_1) {
                result.push(child);
            }
        }
        return result;
    }
    /**
     * Remove the given child.
     */
    removeChild(child) {
        this.setParsedChildren(this.children().filter(node => node !== child));
    }
    /**
     * Whether this node should be cached or not.
     */
    requiresCache() {
        return (this.cache() ||
            this.opacity() < 1 ||
            this.compositeOperation() !== 'source-over' ||
            this.hasFilters() ||
            this.hasShadow() ||
            this.shaders().length > 0);
    }
    cacheCanvas() {
        const canvas = document.createElement('canvas').getContext('2d');
        if (!canvas) {
            throw new Error('Could not create a cache canvas');
        }
        return canvas;
    }
    /**
     * Get a cache canvas with the contents of this node rendered onto it.
     */
    async cachedCanvas() {
        const context = this.cacheCanvas();
        const cache = this.worldSpaceCacheBBox();
        const matrix = this.localToWorld();
        context.canvas.width = cache.width;
        context.canvas.height = cache.height;
        context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e - cache.x, matrix.f - cache.y);
        await this.draw(context);
        return context;
    }
    /**
     * Get a bounding box for the contents rendered by this node.
     *
     * @remarks
     * The returned bounding box should be in local space.
     */
    getCacheBBox() {
        return new BBox();
    }
    /**
     * Get a bounding box for the contents rendered by this node as well
     * as its children.
     */
    cacheBBox() {
        const cache = this.getCacheBBox();
        const children = this.children();
        const padding = this.cachePadding();
        if (children.length === 0) {
            return cache.addSpacing(padding);
        }
        const points = cache.corners;
        for (const child of children) {
            const childCache = child.fullCacheBBox();
            const childMatrix = child.localToParent();
            points.push(...childCache.corners.map(r => r.transformAsPoint(childMatrix)));
        }
        const bbox = BBox.fromPoints(...points);
        return bbox.addSpacing(padding);
    }
    /**
     * Get a bounding box for the contents rendered by this node (including
     * effects applied after caching).
     *
     * @remarks
     * The returned bounding box should be in local space.
     */
    fullCacheBBox() {
        const matrix = this.compositeToLocal();
        const shadowOffset = this.shadowOffset().transform(matrix);
        const shadowBlur = transformScalar(this.shadowBlur(), matrix);
        const result = this.cacheBBox().expand(this.filters.blur() * 2 + shadowBlur);
        if (shadowOffset.x < 0) {
            result.x += shadowOffset.x;
            result.width -= shadowOffset.x;
        }
        else {
            result.width += shadowOffset.x;
        }
        if (shadowOffset.y < 0) {
            result.y += shadowOffset.y;
            result.height -= shadowOffset.y;
        }
        else {
            result.height += shadowOffset.y;
        }
        return result;
    }
    /**
     * Get a bounding box in world space for the contents rendered by this node as
     * well as its children.
     *
     * @remarks
     * This is the same the bounding box returned by {@link cacheBBox} only
     * transformed to world space.
     */
    worldSpaceCacheBBox() {
        const viewBBox = BBox.fromSizeCentered(this.view().size());
        const canvasBBox = BBox.fromPoints(...viewBBox.transformCorners(this.view().localToWorld()));
        const cacheBBox = BBox.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld())).pixelPerfect.expand(2);
        return canvasBBox.intersection(cacheBBox);
    }
    parentWorldSpaceCacheBBox() {
        return (this.findAncestor(node => node.requiresCache())?.worldSpaceCacheBBox() ??
            new BBox(Vector2.zero, useScene2D().getSize()));
    }
    /**
     * Prepare the given context for drawing a cached node onto it.
     *
     * @remarks
     * This method is called before the contents of the cache canvas are drawn
     * on the screen. It can be used to apply effects to the entire node together
     * with its children, instead of applying them individually.
     * Effects such as transparency, shadows, and filters use this technique.
     *
     * Whether the node is cached is decided by the {@link requiresCache} method.
     *
     * @param context - The context using which the cache will be drawn.
     */
    setupDrawFromCache(context) {
        context.globalCompositeOperation = this.compositeOperation();
        context.globalAlpha *= this.opacity();
        if (this.hasFilters()) {
            context.filter = this.filterString();
        }
        if (this.hasShadow()) {
            const matrix = this.compositeToWorld();
            const offset = this.shadowOffset().transform(matrix);
            const blur = transformScalar(this.shadowBlur(), matrix);
            context.shadowColor = this.shadowColor().serialize();
            context.shadowBlur = blur;
            context.shadowOffsetX = offset.x;
            context.shadowOffsetY = offset.y;
        }
        const matrix = this.worldToLocal();
        context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    }
    renderFromSource(context, source, x, y) {
        this.setupDrawFromCache(context);
        const compositeOverride = this.compositeOverride();
        context.drawImage(source, x, y);
        if (compositeOverride > 0) {
            context.save();
            context.globalAlpha *= compositeOverride;
            context.globalCompositeOperation = 'source-over';
            context.drawImage(source, x, y);
            context.restore();
        }
    }
    shaderCanvas(destination, source) {
        const shaders = this.shaders();
        if (shaders.length === 0) {
            return null;
        }
        const scene = useScene2D();
        const size = scene.getRealSize();
        const parentCacheRect = this.parentWorldSpaceCacheBBox();
        const cameraToWorld = new DOMMatrix()
            .scaleSelf(size.width / parentCacheRect.width, size.height / -parentCacheRect.height)
            .translateSelf(parentCacheRect.x / -size.width, parentCacheRect.y / size.height - 1);
        const cacheRect = this.worldSpaceCacheBBox();
        const cameraToCache = new DOMMatrix()
            .scaleSelf(size.width / cacheRect.width, size.height / -cacheRect.height)
            .translateSelf(cacheRect.x / -size.width, cacheRect.y / size.height - 1)
            .invertSelf();
        const gl = scene.shaders.getGL();
        scene.shaders.copyTextures(destination, source);
        scene.shaders.clear();
        for (const shader of shaders) {
            const program = scene.shaders.getProgram(shader.fragment);
            if (!program) {
                continue;
            }
            if (shader.uniforms) {
                for (const [name, uniform] of Object.entries(shader.uniforms)) {
                    const location = gl.getUniformLocation(program, name);
                    if (location === null) {
                        continue;
                    }
                    const value = unwrap(uniform);
                    if (typeof value === 'number') {
                        gl.uniform1f(location, value);
                    }
                    else if ('toUniform' in value) {
                        value.toUniform(gl, location);
                    }
                    else if (value.length === 1) {
                        gl.uniform1f(location, value[0]);
                    }
                    else if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    }
                    else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                    else if (value.length === 4) {
                        gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                    }
                }
            }
            gl.uniform1f(gl.getUniformLocation(program, UNIFORM_TIME), this.view2D.globalTime());
            gl.uniform1i(gl.getUniformLocation(program, UNIFORM_TIME), scene.playback.frame);
            gl.uniformMatrix4fv(gl.getUniformLocation(program, UNIFORM_SOURCE_MATRIX), false, cameraToCache.toFloat32Array());
            gl.uniformMatrix4fv(gl.getUniformLocation(program, UNIFORM_DESTINATION_MATRIX), false, cameraToWorld.toFloat32Array());
            shader.setup?.(gl, program);
            scene.shaders.render();
            shader.teardown?.(gl, program);
        }
        return gl.canvas;
    }
    /**
     * Render this node onto the given canvas.
     *
     * @param context - The context to draw with.
     */
    async render(context) {
        if (this.absoluteOpacity() <= 0) {
            return;
        }
        context.save();
        this.transformContext(context);
        if (this.requiresCache()) {
            const cacheRect = this.worldSpaceCacheBBox();
            if (cacheRect.width !== 0 && cacheRect.height !== 0) {
                const cache = (await this.cachedCanvas()).canvas;
                const source = this.shaderCanvas(context.canvas, cache);
                if (source) {
                    this.renderFromSource(context, source, 0, 0);
                }
                else {
                    this.renderFromSource(context, cache, cacheRect.position.x, cacheRect.position.y);
                }
            }
        }
        else {
            await this.draw(context);
        }
        context.restore();
    }
    /**
     * Draw this node onto the canvas.
     *
     * @remarks
     * This method is used when drawing directly onto the screen as well as onto
     * the cache canvas.
     * It assumes that the context have already been transformed to local space.
     *
     * @param context - The context to draw with.
     */
    async draw(context) {
        await this.drawChildren(context);
    }
    async drawChildren(context) {
        for (const child of this.sortedChildren()) {
            await child.render(context);
        }
    }
    /**
     * Draw an overlay for this node.
     *
     * @remarks
     * The overlay for the currently inspected node is displayed on top of the
     * canvas.
     *
     * The provided context is in screen space. The local-to-screen matrix can be
     * used to transform all shapes that need to be displayed.
     * This approach allows to keep the line widths and gizmo sizes consistent,
     * no matter how zoomed-in the view is.
     *
     * @param context - The context to draw with.
     * @param matrix - A local-to-screen matrix.
     */
    drawOverlay(context, matrix) {
        const box = this.cacheBBox().transformCorners(matrix);
        const cache = this.getCacheBBox().transformCorners(matrix);
        context.strokeStyle = 'white';
        context.lineWidth = 1;
        context.beginPath();
        drawLine(context, box);
        context.closePath();
        context.stroke();
        context.strokeStyle = 'blue';
        context.beginPath();
        drawLine(context, cache);
        context.closePath();
        context.stroke();
    }
    transformContext(context) {
        const matrix = this.localToParent();
        context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    }
    /**
     * Try to find a node intersecting the given position.
     *
     * @param position - The searched position.
     */
    hit(position) {
        let hit = null;
        const local = position.transformAsPoint(this.localToParent().inverse());
        const children = this.children();
        for (let i = children.length - 1; i >= 0; i--) {
            hit = children[i].hit(local);
            if (hit) {
                break;
            }
        }
        return hit;
    }
    /**
     * Collect all asynchronous resources used by this node.
     */
    collectAsyncResources() {
        for (const child of this.children()) {
            child.collectAsyncResources();
        }
    }
    /**
     * Wait for any asynchronous resources that this node or its children have.
     *
     * @remarks
     * Certain resources like images are always loaded asynchronously.
     * Awaiting this method makes sure that all such resources are done loading
     * before continuing the animation.
     */
    async toPromise() {
        do {
            await DependencyContext.consumePromises();
            this.collectAsyncResources();
        } while (DependencyContext.hasPromises());
        return this;
    }
    /**
     * Return a snapshot of the node's current signal values.
     *
     * @remarks
     * This method will calculate the values of any reactive properties of the
     * node at the time the method is called.
     */
    getState() {
        const state = {};
        for (const { key, meta, signal } of this) {
            if (!meta.cloneable || key in state)
                continue;
            state[key] = signal();
        }
        return state;
    }
    applyState(state, duration, timing = easeInOutCubic) {
        if (duration === undefined) {
            for (const key in state) {
                const signal = this.signalByKey(key);
                if (signal) {
                    signal(state[key]);
                }
            }
        }
        const tasks = [];
        for (const key in state) {
            const signal = this.signalByKey(key);
            if (state[key] !== signal.context.raw()) {
                tasks.push(signal(state[key], duration, timing));
            }
        }
        return all(...tasks);
    }
    /**
     * Push a snapshot of the node's current state onto the node's state stack.
     *
     * @remarks
     * This method can be used together with the {@link restore} method to save a
     * node's current state and later restore it. It is possible to store more
     * than one state by calling `save` method multiple times.
     */
    save() {
        this.stateStack.push(this.getState());
    }
    restore(duration, timing = easeInOutCubic) {
        const state = this.stateStack.pop();
        if (state !== undefined) {
            return this.applyState(state, duration, timing);
        }
    }
    *[Symbol.iterator]() {
        for (const key in this.properties) {
            const meta = this.properties[key];
            const signal = this.signalByKey(key);
            yield { meta, signal, key };
        }
    }
    signalByKey(key) {
        return this[key];
    }
    reversedChildren() {
        const children = this.children();
        const result = [];
        for (let i = children.length - 1; i >= 0; i--) {
            result.push(children[i]);
        }
        return result;
    }
};
__decorate([
    vector2Signal()
], Node.prototype, "position", void 0);
__decorate([
    wrapper(Vector2),
    cloneable(false),
    signal()
], Node.prototype, "absolutePosition", void 0);
__decorate([
    initial(0),
    signal()
], Node.prototype, "rotation", void 0);
__decorate([
    cloneable(false),
    signal()
], Node.prototype, "absoluteRotation", void 0);
__decorate([
    initial(Vector2.one),
    vector2Signal('scale')
], Node.prototype, "scale", void 0);
__decorate([
    initial(Vector2.zero),
    vector2Signal('skew')
], Node.prototype, "skew", void 0);
__decorate([
    wrapper(Vector2),
    cloneable(false),
    signal()
], Node.prototype, "absoluteScale", void 0);
__decorate([
    initial(0),
    signal()
], Node.prototype, "zIndex", void 0);
__decorate([
    initial(false),
    signal()
], Node.prototype, "cache", void 0);
__decorate([
    spacingSignal('cachePadding')
], Node.prototype, "cachePadding", void 0);
__decorate([
    initial(false),
    signal()
], Node.prototype, "composite", void 0);
__decorate([
    initial('source-over'),
    signal()
], Node.prototype, "compositeOperation", void 0);
__decorate([
    threadable()
], Node.prototype, "tweenCompositeOperation", null);
__decorate([
    initial(1),
    parser((value) => clamp(0, 1, value)),
    signal()
], Node.prototype, "opacity", void 0);
__decorate([
    computed()
], Node.prototype, "absoluteOpacity", null);
__decorate([
    filtersSignal()
], Node.prototype, "filters", void 0);
__decorate([
    initial('#0000'),
    colorSignal()
], Node.prototype, "shadowColor", void 0);
__decorate([
    initial(0),
    signal()
], Node.prototype, "shadowBlur", void 0);
__decorate([
    vector2Signal('shadowOffset')
], Node.prototype, "shadowOffset", void 0);
__decorate([
    initial([]),
    parser(parseShader),
    signal()
], Node.prototype, "shaders", void 0);
__decorate([
    computed()
], Node.prototype, "hasFilters", null);
__decorate([
    computed()
], Node.prototype, "hasShadow", null);
__decorate([
    computed()
], Node.prototype, "filterString", null);
__decorate([
    inspectable(false),
    cloneable(false),
    signal()
], Node.prototype, "spawner", void 0);
__decorate([
    inspectable(false),
    cloneable(false),
    signal()
], Node.prototype, "children", void 0);
__decorate([
    computed()
], Node.prototype, "spawnedChildren", null);
__decorate([
    computed()
], Node.prototype, "sortedChildren", null);
__decorate([
    computed()
], Node.prototype, "localToWorld", null);
__decorate([
    computed()
], Node.prototype, "worldToLocal", null);
__decorate([
    computed()
], Node.prototype, "worldToParent", null);
__decorate([
    computed()
], Node.prototype, "localToParent", null);
__decorate([
    computed()
], Node.prototype, "compositeToWorld", null);
__decorate([
    computed()
], Node.prototype, "compositeRoot", null);
__decorate([
    computed()
], Node.prototype, "compositeToLocal", null);
__decorate([
    computed()
], Node.prototype, "cacheCanvas", null);
__decorate([
    computed()
], Node.prototype, "cachedCanvas", null);
__decorate([
    computed()
], Node.prototype, "cacheBBox", null);
__decorate([
    computed()
], Node.prototype, "fullCacheBBox", null);
__decorate([
    computed()
], Node.prototype, "worldSpaceCacheBBox", null);
__decorate([
    computed()
], Node.prototype, "parentWorldSpaceCacheBBox", null);
Node = Node_1 = __decorate([
    nodeName('Node')
], Node);
export { Node };
Node.prototype.isClass = true;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9Ob2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxPQUFPLEVBQ0wsSUFBSSxFQUVKLGlCQUFpQixFQWFqQiwwQkFBMEIsRUFDMUIscUJBQXFCLEVBQ3JCLFlBQVksRUFDWixPQUFPLEVBRVAsR0FBRyxFQUNILEtBQUssRUFDTCxZQUFZLEVBQ1osY0FBYyxFQUNkLFVBQVUsRUFDVixNQUFNLEVBQ04sVUFBVSxFQUNWLGNBQWMsRUFDZCxlQUFlLEVBQ2YsTUFBTSxFQUNOLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxXQUFXLEVBQ1gsUUFBUSxFQUNSLGVBQWUsRUFDZixPQUFPLEVBQ1AsaUJBQWlCLEVBQ2pCLFdBQVcsRUFDWCxRQUFRLEVBQ1IsTUFBTSxFQUNOLE1BQU0sRUFDTixhQUFhLEVBQ2IsT0FBTyxHQUNSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBZ0IsYUFBYSxFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFDekUsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLDZCQUE2QixDQUFDO0FBRTFELE9BQU8sRUFHTCxXQUFXLEdBQ1osTUFBTSwwQkFBMEIsQ0FBQztBQUNsQyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQW1FM0IsSUFBTSxJQUFJLFlBQVYsTUFBTSxJQUFJO0lBd0NmLElBQVcsQ0FBQztRQUNWLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUErQixDQUFDO0lBQ3ZELENBQUM7SUFDRCxJQUFXLENBQUM7UUFDVixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBK0IsQ0FBQztJQUN2RCxDQUFDO0lBdUJTLG1CQUFtQjtRQUMzQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDbkMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRVMsbUJBQW1CLENBQUMsS0FBbUM7UUFDL0QsSUFBSSxDQUFDLFFBQVEsQ0FDWCxNQUFNLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxFQUFFLENBQ3hCLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUM5RCxDQUNGLENBQUM7SUFDSixDQUFDO0lBd0JTLG1CQUFtQjtRQUMzQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDbkMsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFUyxtQkFBbUIsQ0FBQyxLQUEwQjtRQUN0RCxJQUFJLENBQUMsUUFBUSxDQUNYLE1BQU0sQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLEVBQUUsQ0FDeEIsY0FBYyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FDaEQsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQXlGUyxnQkFBZ0I7UUFDeEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ25DLE9BQU8sSUFBSSxPQUFPLENBQ2hCLE9BQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQ3pDLE9BQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQzFDLENBQUM7SUFDSixDQUFDO0lBRVMsZ0JBQWdCLENBQUMsS0FBbUM7UUFDNUQsSUFBSSxDQUFDLEtBQUssQ0FDUixNQUFNLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FDMUUsQ0FBQztJQUNKLENBQUM7SUFFTyxnQkFBZ0IsQ0FBQyxLQUFjO1FBQ3JDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxhQUFhLEVBQUUsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ2xFLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBb0NVLEFBQUQsQ0FBQyx1QkFBdUIsQ0FDaEMsS0FBNEMsRUFDNUMsSUFBWSxFQUNaLGNBQThCO1FBRTlCLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoQyxJQUFJLFNBQVMsS0FBSyxhQUFhLEVBQUUsQ0FBQztZQUNoQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQztZQUN2RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7YUFBTSxDQUFDO1lBQ04sSUFBSSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQixLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQztRQUN6RCxDQUFDO0lBQ0gsQ0FBQztJQWNNLGVBQWU7UUFDcEIsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbEUsQ0FBQztJQTZCUyxVQUFVO1FBQ2xCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBR1MsU0FBUztRQUNqQixPQUFPLENBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQztnQkFDcEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDO2dCQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUMvQixDQUFDO0lBQ0osQ0FBQztJQUdTLFlBQVk7UUFDcEIsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3ZDLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7WUFDcEMsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQztnQkFDdEIsT0FBTyxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVDLENBQUM7UUFDSCxDQUFDO1FBRUQsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQVNTLFVBQVU7UUFDbEIsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUNTLFVBQVUsQ0FBQyxLQUFxQztRQUN4RCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFNUyxXQUFXLENBQUMsS0FBcUM7UUFDekQsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsS0FBSyxLQUFLLEVBQUUsQ0FBQztZQUMxQyxPQUFPO1FBQ1QsQ0FBQztRQUVELElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbkMsQ0FBQzthQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUNwQyxLQUFLLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztnQkFDekMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN4QixDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFDUyxXQUFXO1FBQ25CLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQy9CLE9BQU8sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFHUyxlQUFlO1FBQ3ZCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2hELElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUM1QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzNCLENBQUM7SUFHUyxjQUFjO1FBQ3RCLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FDbkMsQ0FBQztJQUNKLENBQUM7SUFZRCxZQUFtQixFQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxFQUFZO1FBeko5QyxzQkFBaUIsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFnSjdDLGVBQVUsR0FBZ0IsRUFBRSxDQUFDO1FBQzNCLGlCQUFZLEdBQVcsRUFBRSxDQUFDO1FBQzFCLHVCQUFrQixHQUFHLEtBQUssQ0FBQztRQUVyQixXQUFNLEdBQUcsWUFBWSxDQUFjLElBQUksQ0FBQyxDQUFDO1FBQ3pDLGVBQVUsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7UUFLakQsTUFBTSxLQUFLLEdBQUcsVUFBVSxFQUFFLENBQUM7UUFDM0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM1RCxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM5QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUMsS0FBSyxDQUFDO1FBQ3ZDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QixJQUFJLE9BQU8sRUFBRSxDQUFDO1lBQ1osU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDO2dCQUNmLE9BQU8sRUFBRSxxQ0FBcUM7Z0JBQzlDLE9BQU8sRUFBRSwyQ0FBMkM7Z0JBQ3BELE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRztnQkFDakIsS0FBSyxFQUFFLElBQUksS0FBSyxFQUFFLENBQUMsS0FBSzthQUN6QixDQUFDLENBQUM7UUFDTCxDQUFDO1FBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBRUksWUFBWTtRQUNqQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDN0IsT0FBTyxNQUFNO1lBQ1gsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3RELENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBRUksWUFBWTtRQUNqQixPQUFPLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBRUksYUFBYTtRQUNsQixPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxZQUFZLEVBQUUsSUFBSSxJQUFJLFNBQVMsRUFBRSxDQUFDO0lBQzFELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFFSSxhQUFhO1FBQ2xCLE1BQU0sTUFBTSxHQUFHLElBQUksU0FBUyxFQUFFLENBQUM7UUFDL0IsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDekMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3pDLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDaEMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFaEMsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFFSSxnQkFBZ0I7UUFDckIsT0FBTyxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQUUsWUFBWSxFQUFFLElBQUksSUFBSSxTQUFTLEVBQUUsQ0FBQztJQUNqRSxDQUFDO0lBR1MsYUFBYTtRQUNyQixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLGFBQWEsRUFBRSxJQUFJLElBQUksQ0FBQztJQUNoRCxDQUFDO0lBR00sZ0JBQWdCO1FBQ3JCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNsQyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ1QsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLFlBQVksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNwRCxDQUFDO1FBQ0QsT0FBTyxJQUFJLFNBQVMsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFTSxJQUFJO1FBQ1QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1Qkc7SUFDSSxHQUFHLENBQUMsSUFBdUI7UUFDaEMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BNkJHO0lBQ0ksTUFBTSxDQUFDLElBQXVCLEVBQUUsS0FBSyxHQUFHLENBQUM7UUFDOUMsTUFBTSxLQUFLLEdBQXFCLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDdkIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTdDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7WUFDekIsSUFBSSxJQUFJLFlBQVksTUFBSSxFQUFFLENBQUM7Z0JBQ3pCLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BCLENBQUM7UUFDSCxDQUFDO1FBRUQsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFcEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNO1FBQ1gsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzlCLElBQUksT0FBTyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNJLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNoQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDN0IsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDeEIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ25DLE1BQU0sV0FBVyxHQUFXLEVBQUUsQ0FBQztRQUUvQixJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUNYLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQ3pDLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDMUIsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFLENBQUM7b0JBQ25CLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQ3RCLE9BQU8sQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQzt3QkFDbEQsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ25DLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQ3pCLENBQUM7UUFDSCxDQUFDO2FBQU0sQ0FBQztZQUNOLEtBQUssSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUM5QyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFCLElBQUksS0FBSyxLQUFLLElBQUksRUFBRSxDQUFDO29CQUNuQixNQUFNLE1BQU0sR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUN0QixPQUFPLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO3dCQUNoQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztvQkFDbkMsQ0FBQztnQkFDSCxDQUFDO2dCQUNELFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7WUFDekIsQ0FBQztRQUNILENBQUM7UUFFRCxNQUFNLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFdEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTTtRQUNYLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksUUFBUTtRQUNiLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxTQUFTO1FBQ2QsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxZQUFZO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksTUFBTSxDQUFDLEtBQWE7UUFDekIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNaLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckQsTUFBTSxFQUFFLEdBQUcsS0FBSyxHQUFHLFlBQVksQ0FBQztRQUVoQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNJLFNBQVMsQ0FBQyxJQUFVLEVBQUUsYUFBYSxHQUFHLEtBQUs7UUFDaEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNaLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLE1BQU0sRUFBRSxDQUFDO1lBQzdCLFNBQVMsRUFBRSxDQUFDLEtBQUssQ0FDZix1RkFBdUYsQ0FDeEYsQ0FBQztZQUNGLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNuQyxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFMUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxRQUFRLEdBQUcsVUFBVSxFQUFFLENBQUM7WUFDNUMseUVBQXlFO1lBQ3pFLHNFQUFzRTtZQUN0RSxvRUFBb0U7WUFDcEUsK0RBQStEO1lBQy9ELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE1BQU0sRUFBRSxHQUFHLFVBQVUsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBRXJDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0ksU0FBUyxDQUFDLElBQVUsRUFBRSxhQUFhLEdBQUcsS0FBSztRQUNoRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDN0IsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ1osT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDN0IsU0FBUyxFQUFFLENBQUMsS0FBSyxDQUNmLHVGQUF1RixDQUN4RixDQUFDO1lBQ0YsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ25DLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEMsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUxQyxJQUFJLENBQUMsYUFBYSxJQUFJLFFBQVEsR0FBRyxVQUFVLEVBQUUsQ0FBQztZQUM1Qyx5RUFBeUU7WUFDekUsc0VBQXNFO1lBQ3RFLHlFQUF5RTtZQUN6RSxzREFBc0Q7WUFDdEQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsTUFBTSxFQUFFLEdBQUcsVUFBVSxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFFckMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLFFBQVEsQ0FBQyxTQUFlO1FBQzdCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3pDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3pDLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNuQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDaEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxjQUFjO1FBQ25CLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsQ0FBQztRQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxZQUFZO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0lBY00sT0FBTyxDQUFpQixTQUFtQztRQUNoRSxNQUFNLE1BQU0sR0FBUSxFQUFFLENBQUM7UUFDdkIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDdEMsT0FBTyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3hCLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUcsQ0FBQztZQUMxQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUNwQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BCLENBQUM7WUFDRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDakMsS0FBSyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQzlDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUIsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBa0JNLFNBQVMsQ0FDZCxTQUFvQztRQUVwQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN0QyxPQUFPLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDeEIsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRyxDQUFDO1lBQzFCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ3BCLE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztZQUNELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNqQyxLQUFLLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztnQkFDOUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQixDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQWtCTSxRQUFRLENBQ2IsU0FBb0M7UUFFcEMsTUFBTSxNQUFNLEdBQVcsRUFBRSxDQUFDO1FBQzFCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRXRDLE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN4QixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFHLENBQUM7WUFDMUIsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDakMsS0FBSyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQzlDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUIsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDekIsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLEdBQUcsRUFBRyxDQUFDO1lBQzNCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ3BCLE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFrQk0sWUFBWSxDQUNqQixTQUFvQztRQUVwQyxJQUFJLE1BQU0sR0FBZ0IsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxFQUFFLENBQUM7WUFDZCxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUN0QixPQUFPLE1BQU0sQ0FBQztZQUNoQixDQUFDO1lBQ0QsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUMzQixDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE9BQU8sQ0FBd0IsS0FBYTtRQUNqRCxPQUFRLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLENBQU8sSUFBSSxJQUFJLENBQUM7SUFDL0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVTtRQUNmLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBUyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7UUFDYixPQUFRLElBQUksQ0FBQyxNQUFNLEVBQVEsSUFBSSxJQUFJLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLE9BQU87UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3JCLE9BQU87UUFDVCxDQUFDO1FBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSyxDQUFDO1FBQ3hCLEtBQUssTUFBTSxFQUFDLE1BQU0sRUFBQyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQzVCLE1BQU0sRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDNUIsQ0FBQztRQUNELEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3RDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNsQixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsY0FBeUIsRUFBRTtRQUN0QyxNQUFNLEtBQUssR0FBRyxFQUFDLEdBQUcsV0FBVyxFQUFDLENBQUM7UUFDL0IsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQzVDLEtBQUssQ0FBQyxRQUFRLEtBQWQsS0FBSyxDQUFDLFFBQVEsR0FBSyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBQztRQUNqRCxDQUFDO2FBQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3RDLEtBQUssQ0FBQyxRQUFRLEtBQWQsS0FBSyxDQUFDLFFBQVEsR0FBSyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUM7UUFDakUsQ0FBQztRQUVELEtBQUssTUFBTSxFQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFDLElBQUksSUFBSSxFQUFFLENBQUM7WUFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksR0FBRyxJQUFJLEtBQUs7Z0JBQUUsU0FBUztZQUM5QyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDbEIsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztvQkFDbkQsSUFBSSxRQUFRLElBQUksS0FBSzt3QkFBRSxTQUFTO29CQUNoQyxNQUFNLFNBQVMsR0FDSCxNQUNWLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ1IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQzt3QkFDbkMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQzVDLENBQUM7Z0JBQ0gsQ0FBQztZQUNILENBQUM7aUJBQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQztnQkFDdkMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDcEMsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksYUFBYSxDQUFDLGNBQXlCLEVBQUU7UUFDOUMsTUFBTSxLQUFLLEdBQUc7WUFDWixHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDbEIsR0FBRyxXQUFXO1NBQ2YsQ0FBQztRQUVGLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUMvQixLQUFLLENBQUMsUUFBUSxLQUFkLEtBQUssQ0FBQyxRQUFRLEdBQUssSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQyxFQUFDO1FBQ3pFLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksYUFBYSxDQUFDLGNBQXlCLEVBQUU7UUFDOUMsTUFBTSxLQUFLLEdBQUcsRUFBQyxHQUFHLFdBQVcsRUFBQyxDQUFDO1FBQy9CLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUMvQixLQUFLLENBQUMsUUFBUSxLQUFkLEtBQUssQ0FBQyxRQUFRLEdBQUssSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQyxFQUFDO1FBQ3pFLENBQUM7UUFFRCxLQUFLLE1BQU0sRUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBQyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLO2dCQUFFLFNBQVM7WUFDOUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzlCLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxXQUFXLENBQUMsUUFBbUIsRUFBRTtRQUN0QyxPQUFPLElBQXVDLElBQUksQ0FBQyxXQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ08saUJBQWlCLENBQUMsS0FBYTtRQUN2QyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7SUFDNUIsQ0FBQztJQUVTLGFBQWEsQ0FBQyxRQUFpQixFQUFFLFFBQTJCO1FBQ3BFLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFcEQsTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUMvQixLQUFLLE1BQU0sUUFBUSxJQUFJLGNBQWMsRUFBRSxDQUFDO1lBQ3RDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBaUIsQ0FBQztZQUM3RCxJQUFJLE9BQU8sSUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFLENBQUM7Z0JBQ2hDLE9BQU8sQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDaEMsQ0FBQztZQUNELElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZCLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsQ0FBQztRQUVELEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUM1QixRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3hCLENBQUM7UUFDSCxDQUFDO1FBRUQsSUFBSSxDQUFDLGtCQUFrQixHQUFHLFFBQVEsQ0FBQztRQUNuQyxJQUFJLENBQUMsWUFBWSxHQUFHLGNBQWMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLGFBQWEsQ0FBQyxRQUEyQjtRQUNqRCxNQUFNLE1BQU0sR0FBVyxFQUFFLENBQUM7UUFDMUIsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzlELEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxFQUFFLENBQUM7WUFDMUIsSUFBSSxLQUFLLFlBQVksTUFBSSxFQUFFLENBQUM7Z0JBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckIsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7O09BRUc7SUFDTyxXQUFXLENBQUMsS0FBVztRQUMvQixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7T0FFRztJQUNPLGFBQWE7UUFDckIsT0FBTyxDQUNMLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDWixJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQztZQUNsQixJQUFJLENBQUMsa0JBQWtCLEVBQUUsS0FBSyxhQUFhO1lBQzNDLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNoQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FDMUIsQ0FBQztJQUNKLENBQUM7SUFHUyxXQUFXO1FBQ25CLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztRQUNyRCxDQUFDO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOztPQUVHO0lBRWEsQUFBTixLQUFLLENBQUMsWUFBWTtRQUMxQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDbkMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDekMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBRW5DLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDbkMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUVyQyxPQUFPLENBQUMsWUFBWSxDQUNsQixNQUFNLENBQUMsQ0FBQyxFQUNSLE1BQU0sQ0FBQyxDQUFDLEVBQ1IsTUFBTSxDQUFDLENBQUMsRUFDUixNQUFNLENBQUMsQ0FBQyxFQUNSLE1BQU0sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFDbEIsTUFBTSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUNuQixDQUFDO1FBQ0YsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXpCLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLFlBQVk7UUFDcEIsT0FBTyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7O09BR0c7SUFFSSxTQUFTO1FBQ2QsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ2xDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEMsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQzFCLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBRUQsTUFBTSxNQUFNLEdBQWMsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUN4QyxLQUFLLE1BQU0sS0FBSyxJQUFJLFFBQVEsRUFBRSxDQUFDO1lBQzdCLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUN6QyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDMUMsTUFBTSxDQUFDLElBQUksQ0FDVCxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQ2hFLENBQUM7UUFDSixDQUFDO1FBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBRU8sYUFBYTtRQUNyQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN2QyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNELE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFOUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLE1BQU0sQ0FDcEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsVUFBVSxDQUNyQyxDQUFDO1FBRUYsSUFBSSxZQUFZLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ3ZCLE1BQU0sQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQztZQUMzQixNQUFNLENBQUMsS0FBSyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDakMsQ0FBQzthQUFNLENBQUM7WUFDTixNQUFNLENBQUMsS0FBSyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDakMsQ0FBQztRQUVELElBQUksWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN2QixNQUFNLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUM7WUFDM0IsTUFBTSxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLENBQUM7YUFBTSxDQUFDO1lBQ04sTUFBTSxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUVPLG1CQUFtQjtRQUMzQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDM0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FDaEMsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQ3pELENBQUM7UUFDRixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUMvQixHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FDMUQsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXpCLE9BQU8sVUFBVSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBR1MseUJBQXlCO1FBQ2pDLE9BQU8sQ0FDTCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLEVBQUUsbUJBQW1CLEVBQUU7WUFDdEUsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUMvQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNPLGtCQUFrQixDQUFDLE9BQWlDO1FBQzVELE9BQU8sQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUM3RCxPQUFPLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0QyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDO1lBQ3RCLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3ZDLENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDO1lBQ3JCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3ZDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDckQsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUV4RCxPQUFPLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyRCxPQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztZQUMxQixPQUFPLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDakMsT0FBTyxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUM7UUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDbkMsT0FBTyxDQUFDLFNBQVMsQ0FDZixNQUFNLENBQUMsQ0FBQyxFQUNSLE1BQU0sQ0FBQyxDQUFDLEVBQ1IsTUFBTSxDQUFDLENBQUMsRUFDUixNQUFNLENBQUMsQ0FBQyxFQUNSLE1BQU0sQ0FBQyxDQUFDLEVBQ1IsTUFBTSxDQUFDLENBQUMsQ0FDVCxDQUFDO0lBQ0osQ0FBQztJQUVTLGdCQUFnQixDQUN4QixPQUFpQyxFQUNqQyxNQUF5QixFQUN6QixDQUFTLEVBQ1QsQ0FBUztRQUVULElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVqQyxNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ25ELE9BQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNoQyxJQUFJLGlCQUFpQixHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzFCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNmLE9BQU8sQ0FBQyxXQUFXLElBQUksaUJBQWlCLENBQUM7WUFDekMsT0FBTyxDQUFDLHdCQUF3QixHQUFHLGFBQWEsQ0FBQztZQUNqRCxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3BCLENBQUM7SUFDSCxDQUFDO0lBRU8sWUFBWSxDQUFDLFdBQTJCLEVBQUUsTUFBc0I7UUFDdEUsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQy9CLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN6QixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCxNQUFNLEtBQUssR0FBRyxVQUFVLEVBQUUsQ0FBQztRQUMzQixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDakMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7UUFDekQsTUFBTSxhQUFhLEdBQUcsSUFBSSxTQUFTLEVBQUU7YUFDbEMsU0FBUyxDQUNSLElBQUksQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDLEtBQUssRUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQ3RDO2FBQ0EsYUFBYSxDQUNaLGVBQWUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUMvQixlQUFlLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUNwQyxDQUFDO1FBRUosTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDN0MsTUFBTSxhQUFhLEdBQUcsSUFBSSxTQUFTLEVBQUU7YUFDbEMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQzthQUN4RSxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzthQUN2RSxVQUFVLEVBQUUsQ0FBQztRQUVoQixNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pDLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNoRCxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBRXRCLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxFQUFFLENBQUM7WUFDN0IsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzFELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDYixTQUFTO1lBQ1gsQ0FBQztZQUVELElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNwQixLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztvQkFDOUQsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDdEQsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFLENBQUM7d0JBQ3RCLFNBQVM7b0JBQ1gsQ0FBQztvQkFFRCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQzlCLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFLENBQUM7d0JBQzlCLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUNoQyxDQUFDO3lCQUFNLElBQUksV0FBVyxJQUFJLEtBQUssRUFBRSxDQUFDO3dCQUNoQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztvQkFDaEMsQ0FBQzt5QkFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQzlCLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNuQyxDQUFDO3lCQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQzt3QkFDOUIsRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM3QyxDQUFDO3lCQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQzt3QkFDOUIsRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDdkQsQ0FBQzt5QkFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQzlCLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNqRSxDQUFDO2dCQUNILENBQUM7WUFDSCxDQUFDO1lBRUQsRUFBRSxDQUFDLFNBQVMsQ0FDVixFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxFQUM1QyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUN6QixDQUFDO1lBRUYsRUFBRSxDQUFDLFNBQVMsQ0FDVixFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxFQUM1QyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FDckIsQ0FBQztZQUVGLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FDakIsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxxQkFBcUIsQ0FBQyxFQUNyRCxLQUFLLEVBQ0wsYUFBYSxDQUFDLGNBQWMsRUFBRSxDQUMvQixDQUFDO1lBRUYsRUFBRSxDQUFDLGdCQUFnQixDQUNqQixFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLDBCQUEwQixDQUFDLEVBQzFELEtBQUssRUFDTCxhQUFhLENBQUMsY0FBYyxFQUFFLENBQy9CLENBQUM7WUFFRixNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzVCLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDdkIsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNqQyxDQUFDO1FBRUQsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFpQztRQUNuRCxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUNoQyxPQUFPO1FBQ1QsQ0FBQztRQUVELE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNmLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUUvQixJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDO1lBQ3pCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1lBQzdDLElBQUksU0FBUyxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDcEQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQztnQkFDakQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUN4RCxJQUFJLE1BQU0sRUFBRSxDQUFDO29CQUNYLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDL0MsQ0FBQztxQkFBTSxDQUFDO29CQUNOLElBQUksQ0FBQyxnQkFBZ0IsQ0FDbkIsT0FBTyxFQUNQLEtBQUssRUFDTCxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsRUFDcEIsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQ3JCLENBQUM7Z0JBQ0osQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO2FBQU0sQ0FBQztZQUNOLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQixDQUFDO1FBRUQsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDTyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQWlDO1FBQ3BELE1BQU0sSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRVMsS0FBSyxDQUFDLFlBQVksQ0FBQyxPQUFpQztRQUM1RCxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDO1lBQzFDLE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0ksV0FBVyxDQUFDLE9BQWlDLEVBQUUsTUFBaUI7UUFDckUsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzRCxPQUFPLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQztRQUM5QixPQUFPLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztRQUN0QixPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDcEIsUUFBUSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN2QixPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDcEIsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRWpCLE9BQU8sQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDO1FBQzdCLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQixRQUFRLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3pCLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVTLGdCQUFnQixDQUFDLE9BQWlDO1FBQzFELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNwQyxPQUFPLENBQUMsU0FBUyxDQUNmLE1BQU0sQ0FBQyxDQUFDLEVBQ1IsTUFBTSxDQUFDLENBQUMsRUFDUixNQUFNLENBQUMsQ0FBQyxFQUNSLE1BQU0sQ0FBQyxDQUFDLEVBQ1IsTUFBTSxDQUFDLENBQUMsRUFDUixNQUFNLENBQUMsQ0FBQyxDQUNULENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEdBQUcsQ0FBQyxRQUFpQjtRQUMxQixJQUFJLEdBQUcsR0FBZ0IsSUFBSSxDQUFDO1FBQzVCLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUN4RSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakMsS0FBSyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDOUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDN0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDUixNQUFNO1lBQ1IsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNPLHFCQUFxQjtRQUM3QixLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDO1lBQ3BDLEtBQUssQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQ2hDLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLEtBQUssQ0FBQyxTQUFTO1FBQ3BCLEdBQUcsQ0FBQztZQUNGLE1BQU0saUJBQWlCLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDMUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDL0IsQ0FBQyxRQUFRLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxFQUFFO1FBQzFDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFFBQVE7UUFDYixNQUFNLEtBQUssR0FBYyxFQUFFLENBQUM7UUFDNUIsS0FBSyxNQUFNLEVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxHQUFHLElBQUksS0FBSztnQkFBRSxTQUFTO1lBQzlDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQztRQUN4QixDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBc0JNLFVBQVUsQ0FDZixLQUFnQixFQUNoQixRQUFpQixFQUNqQixTQUF5QixjQUFjO1FBRXZDLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzNCLEtBQUssTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7Z0JBQ3hCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksTUFBTSxFQUFFLENBQUM7b0JBQ1gsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUNyQixDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7UUFFRCxNQUFNLEtBQUssR0FBc0IsRUFBRSxDQUFDO1FBQ3BDLEtBQUssTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7WUFDeEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7Z0JBQ3hDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxRQUFTLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNwRCxDQUFDO1FBQ0gsQ0FBQztRQUVELE9BQU8sR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxJQUFJO1FBQ1QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQXlETSxPQUFPLENBQ1osUUFBaUIsRUFDakIsU0FBeUIsY0FBYztRQUV2QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRXBDLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3hCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsUUFBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ25ELENBQUM7SUFDSCxDQUFDO0lBRU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDdkIsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDbEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNsQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3JDLE1BQU0sRUFBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBQyxDQUFDO1FBQzVCLENBQUM7SUFDSCxDQUFDO0lBRU8sV0FBVyxDQUFDLEdBQVc7UUFDN0IsT0FBcUQsSUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFTyxnQkFBZ0I7UUFDdEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sTUFBTSxHQUFXLEVBQUUsQ0FBQztRQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM5QyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNCLENBQUM7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0YsQ0FBQTtBQXZ1RHlCO0lBRHZCLGFBQWEsRUFBRTtzQ0FDc0M7QUE0QjlCO0lBSHZCLE9BQU8sQ0FBQyxPQUFPLENBQUM7SUFDaEIsU0FBUyxDQUFDLEtBQUssQ0FBQztJQUNoQixNQUFNLEVBQUU7OENBQzJEO0FBb0I1QztJQUZ2QixPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ1YsTUFBTSxFQUFFO3NDQUNvRDtBQWVyQztJQUZ2QixTQUFTLENBQUMsS0FBSyxDQUFDO0lBQ2hCLE1BQU0sRUFBRTs4Q0FDNEQ7QUErQzdDO0lBRnZCLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBQ3BCLGFBQWEsQ0FBQyxPQUFPLENBQUM7bUNBQzRCO0FBa0MzQjtJQUZ2QixPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNyQixhQUFhLENBQUMsTUFBTSxDQUFDO2tDQUM0QjtBQW1CMUI7SUFIdkIsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQixTQUFTLENBQUMsS0FBSyxDQUFDO0lBQ2hCLE1BQU0sRUFBRTsyQ0FDd0Q7QUF1QnpDO0lBRnZCLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDVixNQUFNLEVBQUU7b0NBQ2tEO0FBSW5DO0lBRnZCLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDZCxNQUFNLEVBQUU7bUNBQ2tEO0FBWW5DO0lBRHZCLGFBQWEsQ0FBQyxjQUFjLENBQUM7MENBQzRCO0FBSWxDO0lBRnZCLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDZCxNQUFNLEVBQUU7dUNBQ3NEO0FBSXZDO0lBRnZCLE9BQU8sQ0FBQyxhQUFhLENBQUM7SUFDdEIsTUFBTSxFQUFFO2dEQUlQO0FBS1M7SUFEVixVQUFVLEVBQUU7bURBZ0JaO0FBV3VCO0lBSHZCLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDVixNQUFNLENBQUMsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzdDLE1BQU0sRUFBRTtxQ0FDbUQ7QUFHckQ7SUFETixRQUFRLEVBQUU7MkNBR1Y7QUFHdUI7SUFEdkIsYUFBYSxFQUFFO3FDQUNxQztBQUk3QjtJQUZ2QixPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hCLFdBQVcsRUFBRTt5Q0FDeUM7QUFJL0I7SUFGdkIsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNWLE1BQU0sRUFBRTt3Q0FDc0Q7QUFHdkM7SUFEdkIsYUFBYSxDQUFDLGNBQWMsQ0FBQzswQ0FDNEI7QUFRbEM7SUFIdkIsT0FBTyxDQUFDLEVBQUUsQ0FBQztJQUNYLE1BQU0sQ0FBQyxXQUFXLENBQUM7SUFDbkIsTUFBTSxFQUFFO3FDQUtQO0FBR1E7SUFEVCxRQUFRLEVBQUU7c0NBR1Y7QUFHUztJQURULFFBQVEsRUFBRTtxQ0FRVjtBQUdTO0lBRFQsUUFBUSxFQUFFO3dDQVdWO0FBUTBCO0lBSDFCLFdBQVcsQ0FBQyxLQUFLLENBQUM7SUFDbEIsU0FBUyxDQUFDLEtBQUssQ0FBQztJQUNoQixNQUFNLEVBQUU7cUNBQ2lFO0FBV2xEO0lBSHZCLFdBQVcsQ0FBQyxLQUFLLENBQUM7SUFDbEIsU0FBUyxDQUFDLEtBQUssQ0FBQztJQUNoQixNQUFNLEVBQUU7c0NBQ2lFO0FBcUJoRTtJQURULFFBQVEsRUFBRTsyQ0FPVjtBQUdTO0lBRFQsUUFBUSxFQUFFOzBDQUtWO0FBNkNNO0lBRE4sUUFBUSxFQUFFO3dDQU1WO0FBa0JNO0lBRE4sUUFBUSxFQUFFO3dDQUdWO0FBVU07SUFETixRQUFRLEVBQUU7eUNBR1Y7QUFVTTtJQUROLFFBQVEsRUFBRTt5Q0FVVjtBQVdNO0lBRE4sUUFBUSxFQUFFOzRDQUdWO0FBR1M7SUFEVCxRQUFRLEVBQUU7eUNBT1Y7QUFHTTtJQUROLFFBQVEsRUFBRTs0Q0FTVjtBQW9yQlM7SUFEVCxRQUFRLEVBQUU7dUNBUVY7QUFNZTtJQURmLFFBQVEsRUFBRTt3Q0FvQlY7QUFpQk07SUFETixRQUFRLEVBQUU7cUNBb0JWO0FBVVM7SUFEVCxRQUFRLEVBQUU7eUNBeUJWO0FBV1M7SUFEVCxRQUFRLEVBQUU7K0NBV1Y7QUFHUztJQURULFFBQVEsRUFBRTtxREFNVjtBQXYwQ1UsSUFBSTtJQURoQixRQUFRLENBQUMsTUFBTSxDQUFDO0dBQ0osSUFBSSxDQTZ3RGhCOztBQUVELElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyJ9