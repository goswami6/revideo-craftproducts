import { capitalize, deepLerp, SignalContext, useLogger, } from '@revideo/core';
import { makeSignalExtensions } from '../utils/makeSignalExtensions';
import { addInitializer, initialize } from './initializers';
const PROPERTIES = Symbol.for('@revideo/2d/decorators/properties');
export function getPropertyMeta(object, key) {
    return object[PROPERTIES]?.[key] ?? null;
}
export function getPropertyMetaOrCreate(object, key) {
    let lookup;
    if (!object[PROPERTIES]) {
        object[PROPERTIES] = lookup = {};
    }
    else if (object[PROPERTIES] &&
        !Object.prototype.hasOwnProperty.call(object, PROPERTIES)) {
        object[PROPERTIES] = lookup = Object.fromEntries(Object.entries(object[PROPERTIES]).map(([key, meta]) => [key, { ...meta }]));
    }
    else {
        lookup = object[PROPERTIES];
    }
    lookup[key] ?? (lookup[key] = {
        cloneable: true,
        inspectable: true,
        compoundEntries: [],
    });
    return lookup[key];
}
export function getPropertiesOf(value) {
    if (value && typeof value === 'object') {
        return value[PROPERTIES] ?? {};
    }
    return {};
}
export function initializeSignals(instance, props) {
    initialize(instance);
    for (const [key, meta] of Object.entries(getPropertiesOf(instance))) {
        const signal = instance[key];
        signal.reset();
        if (props[key] !== undefined) {
            signal(props[key]);
        }
        if (meta.compoundEntries !== undefined) {
            for (const [key, property] of meta.compoundEntries) {
                if (property in props) {
                    signal[key](props[property]);
                }
            }
        }
    }
}
/**
 * Create a signal decorator.
 *
 * @remarks
 * This decorator turns the given property into a signal.
 *
 * The class using this decorator can implement the following methods:
 * - `get[PropertyName]` - A property getter.
 * - `get[PropertyName]` - A property setter.
 * - `tween[PropertyName]` - A tween provider.
 *
 * @example
 * ```ts
 * class Example {
 *   \@property()
 *   public declare length: Signal<number, this>;
 * }
 * ```
 */
export function signal() {
    return (target, key) => {
        // FIXME property metadata is not inherited
        // Consider retrieving it inside the initializer using the instance and not
        // the class.
        const meta = getPropertyMetaOrCreate(target, key);
        addInitializer(target, (instance) => {
            let initial = meta.default;
            const defaultMethod = instance[`getDefault${capitalize(key)}`];
            if (defaultMethod) {
                initial = () => defaultMethod.call(instance, meta.default);
            }
            const signal = new SignalContext(initial, meta.interpolationFunction ?? deepLerp, instance, meta.parser?.bind(instance), makeSignalExtensions(meta, instance, key));
            instance[key] = signal.toSignal();
        });
    };
}
/**
 * Create an initial signal value decorator.
 *
 * @remarks
 * This decorator specifies the initial value of a property.
 *
 * Must be specified before the {@link signal} decorator.
 *
 * @example
 * ```ts
 * class Example {
 *   \@initial(1)
 *   \@property()
 *   public declare length: Signal<number, this>;
 * }
 * ```
 *
 * @param value - The initial value of the property.
 */
export function initial(value) {
    return (target, key) => {
        const meta = getPropertyMeta(target, key);
        if (!meta) {
            useLogger().error(`Missing property decorator for "${key.toString()}"`);
            return;
        }
        meta.default = value;
    };
}
/**
 * Create a signal interpolation function decorator.
 *
 * @remarks
 * This decorator specifies the interpolation function of a property.
 * The interpolation function is used when tweening between different values.
 *
 * Must be specified before the {@link signal} decorator.
 *
 * @example
 * ```ts
 * class Example {
 *   \@interpolation(textLerp)
 *   \@property()
 *   public declare text: Signal<string, this>;
 * }
 * ```
 *
 * @param value - The interpolation function for the property.
 */
export function interpolation(value) {
    return (target, key) => {
        const meta = getPropertyMeta(target, key);
        if (!meta) {
            useLogger().error(`Missing property decorator for "${key.toString()}"`);
            return;
        }
        meta.interpolationFunction = value;
    };
}
/**
 * Create a signal parser decorator.
 *
 * @remarks
 * This decorator specifies the parser of a property.
 * Instead of returning the raw value, its passed as the first parameter to the
 * parser and the resulting value is returned.
 *
 * If the wrapper class has a method called `lerp` it will be set as the
 * default interpolation function for the property.
 *
 * Must be specified before the {@link signal} decorator.
 *
 * @example
 * ```ts
 * class Example {
 *   \@wrapper(Vector2)
 *   \@property()
 *   public declare offset: Signal<Vector2, this>;
 * }
 * ```
 *
 * @param value - The wrapper class for the property.
 */
export function parser(value) {
    return (target, key) => {
        const meta = getPropertyMeta(target, key);
        if (!meta) {
            useLogger().error(`Missing property decorator for "${key.toString()}"`);
            return;
        }
        meta.parser = value;
    };
}
/**
 * Create a signal wrapper decorator.
 *
 * @remarks
 * This is a shortcut decorator for setting both the {@link parser} and
 * {@link interpolation}.
 *
 * The interpolation function will be set only if the wrapper class has a method
 * called `lerp`, which will be used as said function.
 *
 * Must be specified before the {@link signal} decorator.
 *
 * @example
 * ```ts
 * class Example {
 *   \@wrapper(Vector2)
 *   \@property()
 *   public declare offset: Signal<Vector2, this>;
 *
 *   // same as:
 *   \@parser(value => new Vector2(value))
 *   \@interpolation(Vector2.lerp)
 *   \@property()
 *   public declare offset: Signal<Vector2, this>;
 * }
 * ```
 *
 * @param value - The wrapper class for the property.
 */
export function wrapper(value) {
    return (target, key) => {
        const meta = getPropertyMeta(target, key);
        if (!meta) {
            useLogger().error(`Missing property decorator for "${key.toString()}"`);
            return;
        }
        meta.parser = raw => new value(raw);
        if ('lerp' in value) {
            meta.interpolationFunction ?? (meta.interpolationFunction = value.lerp);
        }
    };
}
/**
 * Create a cloneable property decorator.
 *
 * @remarks
 * This decorator specifies whether the property should be copied over when
 * cloning the node.
 *
 * By default, any property is cloneable.
 *
 * Must be specified before the {@link signal} decorator.
 *
 * @example
 * ```ts
 * class Example {
 *   \@clone(false)
 *   \@property()
 *   public declare length: Signal<number, this>;
 * }
 * ```
 *
 * @param value - Whether the property should be cloneable.
 */
export function cloneable(value = true) {
    return (target, key) => {
        const meta = getPropertyMeta(target, key);
        if (!meta) {
            useLogger().error(`Missing property decorator for "${key.toString()}"`);
            return;
        }
        meta.cloneable = value;
    };
}
/**
 * Create an inspectable property decorator.
 *
 * @remarks
 * This decorator specifies whether the property should be visible in the
 * inspector.
 *
 * By default, any property is inspectable.
 *
 * Must be specified before the {@link signal} decorator.
 *
 * @example
 * ```ts
 * class Example {
 *   \@inspectable(false)
 *   \@property()
 *   public declare hiddenLength: Signal<number, this>;
 * }
 * ```
 *
 * @param value - Whether the property should be inspectable.
 */
export function inspectable(value = true) {
    return (target, key) => {
        const meta = getPropertyMeta(target, key);
        if (!meta) {
            useLogger().error(`Missing property decorator for "${key.toString()}"`);
            return;
        }
        meta.inspectable = value;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9kZWNvcmF0b3JzL3NpZ25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsVUFBVSxFQUNWLFFBQVEsRUFFUixhQUFhLEVBR2IsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBQ25FLE9BQU8sRUFBQyxjQUFjLEVBQUUsVUFBVSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFxQjFELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsbUNBQW1DLENBQUMsQ0FBQztBQUVuRSxNQUFNLFVBQVUsZUFBZSxDQUM3QixNQUFXLEVBQ1gsR0FBb0I7SUFFcEIsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDM0MsQ0FBQztBQUVELE1BQU0sVUFBVSx1QkFBdUIsQ0FDckMsTUFBVyxFQUNYLEdBQW9CO0lBRXBCLElBQUksTUFBb0QsQ0FBQztJQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7UUFDeEIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDbkMsQ0FBQztTQUFNLElBQ0wsTUFBTSxDQUFDLFVBQVUsQ0FBQztRQUNsQixDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLEVBQ3pELENBQUM7UUFDRCxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQzlDLE1BQU0sQ0FBQyxPQUFPLENBQ2tDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FDakUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBQyxHQUFHLElBQUksRUFBQyxDQUFDLENBQUMsQ0FDekMsQ0FBQztJQUNKLENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsTUFBTSxDQUFDLEdBQUcsTUFBVixNQUFNLENBQUMsR0FBRyxJQUFNO1FBQ2QsU0FBUyxFQUFFLElBQUk7UUFDZixXQUFXLEVBQUUsSUFBSTtRQUNqQixlQUFlLEVBQUUsRUFBRTtLQUNwQixFQUFDO0lBQ0YsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckIsQ0FBQztBQUVELE1BQU0sVUFBVSxlQUFlLENBQzdCLEtBQVU7SUFFVixJQUFJLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUN2QyxPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVELE9BQU8sRUFBRSxDQUFDO0FBQ1osQ0FBQztBQUVELE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxRQUFhLEVBQUUsS0FBMEI7SUFDekUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JCLEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDcEUsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNmLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzdCLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNyQixDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUMsZUFBZSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3ZDLEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7Z0JBQ25ELElBQUksUUFBUSxJQUFJLEtBQUssRUFBRSxDQUFDO29CQUN0QixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQy9CLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUNILE1BQU0sVUFBVSxNQUFNO0lBQ3BCLE9BQU8sQ0FBQyxNQUFXLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDMUIsMkNBQTJDO1FBQzNDLDJFQUEyRTtRQUMzRSxhQUFhO1FBQ2IsTUFBTSxJQUFJLEdBQUcsdUJBQXVCLENBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3JELGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFhLEVBQUUsRUFBRTtZQUN2QyxJQUFJLE9BQU8sR0FBbUIsSUFBSSxDQUFDLE9BQVEsQ0FBQztZQUM1QyxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsYUFBYSxVQUFVLENBQUMsR0FBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3pFLElBQUksYUFBYSxFQUFFLENBQUM7Z0JBQ2xCLE9BQU8sR0FBRyxHQUFHLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDN0QsQ0FBQztZQUVELE1BQU0sTUFBTSxHQUFHLElBQUksYUFBYSxDQUM5QixPQUFPLEVBQ1AsSUFBSSxDQUFDLHFCQUFxQixJQUFJLFFBQVEsRUFDdEMsUUFBUSxFQUNSLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUMzQixvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFVLEdBQUcsQ0FBQyxDQUNsRCxDQUFDO1lBQ0YsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNwQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FBSSxLQUFRO0lBQ2pDLE9BQU8sQ0FBQyxNQUFXLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDMUIsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFJLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDVixTQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsbUNBQW1DLEdBQUcsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDeEUsT0FBTztRQUNULENBQUM7UUFDRCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztJQUN2QixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUMzQixLQUErQjtJQUUvQixPQUFPLENBQUMsTUFBVyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQzFCLE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1YsU0FBUyxFQUFFLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxHQUFHLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3hFLE9BQU87UUFDVCxDQUFDO1FBQ0QsSUFBSSxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQztJQUNyQyxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FBSSxLQUF3QjtJQUNoRCxPQUFPLENBQUMsTUFBVyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQzFCLE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1YsU0FBUyxFQUFFLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxHQUFHLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3hFLE9BQU87UUFDVCxDQUFDO1FBQ0QsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7SUFDdEIsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FDckIsS0FBa0U7SUFFbEUsT0FBTyxDQUFDLE1BQVcsRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUMxQixNQUFNLElBQUksR0FBRyxlQUFlLENBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLFNBQVMsRUFBRSxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUN4RSxPQUFPO1FBQ1QsQ0FBQztRQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwQyxJQUFJLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMscUJBQXFCLEtBQTFCLElBQUksQ0FBQyxxQkFBcUIsR0FBSyxLQUFLLENBQUMsSUFBSSxFQUFDO1FBQzVDLENBQUM7SUFDSCxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQUksS0FBSyxHQUFHLElBQUk7SUFDdkMsT0FBTyxDQUFDLE1BQVcsRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUMxQixNQUFNLElBQUksR0FBRyxlQUFlLENBQUksTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLFNBQVMsRUFBRSxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUN4RSxPQUFPO1FBQ1QsQ0FBQztRQUNELElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0lBQ3pCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUJHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBSSxLQUFLLEdBQUcsSUFBSTtJQUN6QyxPQUFPLENBQUMsTUFBVyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQzFCLE1BQU0sSUFBSSxHQUFHLGVBQWUsQ0FBSSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1YsU0FBUyxFQUFFLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxHQUFHLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3hFLE9BQU87UUFDVCxDQUFDO1FBQ0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQyxDQUFDO0FBQ0osQ0FBQyJ9