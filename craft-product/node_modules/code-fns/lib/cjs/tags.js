"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.diff = diff;
exports.getColor = getColor;
exports.language = void 0;
exports.parse = parse;
exports.ready = ready;
exports.toString = toString;

var _starryNight = require("@wooorm/starry-night");

var _darkStyle = _interopRequireDefault(require("./dark-style"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const starryNight = (0, _starryNight.createStarryNight)(_starryNight.all);
let starryNightCache = null;

async function ready() {
  starryNightCache = await starryNight;
}

const handler = {
  get(_, language) {
    return (code, ...rest) => {
      return {
        language,
        spans: Array.from(code),
        nodes: rest
      };
    };
  }

};
const language = new Proxy({}, handler);
exports.language = language;

function parse(code, options) {
  const raw = integrate(reindent(code));
  if (starryNightCache == null) throw new Error(`you must await ready()`);
  const sn = starryNightCache;
  const scope = sn.flagToScope(code.language);

  if (typeof scope !== 'string') {
    throw new Error(`language ${code.language} not found`);
  }

  const parsed = sn.highlight(raw, scope);
  return parsed.children.map(child => colorRecurse(child, (options === null || options === void 0 ? void 0 : options.codeStyle) ?? {})).flat().map(({
    color,
    ...rest
  }) => ({ ...rest,
    color: color === '' ? '#c9d1d9' : color
  }));
}

const rules = new Map(Object.entries(_darkStyle.default).map(([k, v]) => [k, new Map(Object.entries(v))]));
const styleMap = new Map([['pl-s', 'stringContent'], ['pl-pds', 'stringPunctuation'], ['pl-c', 'comment'], ['pl-smi', 'variable'], ['pl-v', 'parameter'], ['pl-sr', 'regexpContent'], ['pl-c1', 'literal'], ['pl-k', 'keyword'], ['pl-en', 'entityName']]);

function getColor(classList, codeStyle) {
  console.assert(classList.length <= 1, `classList too long`);

  if (classList.length === 1) {
    const key = styleMap.get(classList[0]);

    if (key != null && codeStyle[key] != null) {
      var _codeStyle$key;

      return (_codeStyle$key = codeStyle[key]) === null || _codeStyle$key === void 0 ? void 0 : _codeStyle$key.text;
    }

    const styles = rules.get(`.${classList[0]}`);
    console.assert(((styles === null || styles === void 0 ? void 0 : styles.size) ?? 0) <= 1, `more styles than just color`);
    return styles === null || styles === void 0 ? void 0 : styles.get('color');
  }

  return undefined;
}

function colorRecurse(parsed, codeStyle) {
  if (parsed.type === 'text') {
    return [{
      code: parsed.value,
      color: ''
    }];
  } else if (parsed.type === 'element') {
    var _parsed$properties;

    const className = (_parsed$properties = parsed.properties) === null || _parsed$properties === void 0 ? void 0 : _parsed$properties.className;
    const color = getColor(className ?? [], codeStyle);
    const children = parsed.children.map(child => colorRecurse(child, codeStyle));
    const result = [];

    const emit = () => {
      if (temp !== '') {
        if (color != '') {
          result.push({
            code: temp,
            color
          });
        } else {
          result.push({
            code: temp,
            color: ''
          });
        }

        temp = '';
      }
    };

    let temp = '';

    for (const child of children) {
      for (const item of child) {
        if (item.color === '') {
          temp += item.code;
        } else {
          emit();
          result.push(item);
        }
      }

      emit();
    }

    emit();
    return result;
  } else {
    throw new Error();
  }
}

function toString(tokens) {
  return tokens.map(token => token.code).join('');
}

function reindent(code, indent = 0) {
  var _code$spans$at;

  if (typeof code === 'string') {
    if (code.at(0) !== '\n') {
      return ' '.repeat(indent) + code;
    }

    const regex = /^ +/gm;
    const matches = code.matchAll(regex);
    let min = Infinity;

    for (const match of matches) min = Math.min(min, match[0].length);

    const undent = new RegExp(`^ {${min}}`, 'gm');
    const result = code.substring(1).replace(undent, ' '.repeat(indent));
    return result;
  }

  if (((_code$spans$at = code.spans.at(0)) === null || _code$spans$at === void 0 ? void 0 : _code$spans$at.at(0)) !== '\n') return code;
  const regex = /\n */g;
  const matches = code.spans.flatMap(span => [...span.matchAll(regex)]);
  let min = Infinity;

  for (const [match] of matches) min = Math.min(min, match.length - 1);

  const undentRegex = new RegExp(`\n {${min}}`, 'g');
  const spans = code.spans.map(span => span.replace(undentRegex, '\n' + ' '.repeat(indent)));
  spans[0] = spans[0].substring(1);
  let index = 0;
  const nodes = [];

  for (const node of code.nodes) {
    const before = spans[index];
    const preindentRegex = /\n *$/;
    const indentation = before.match(preindentRegex);

    if (indentation != null) {
      spans[index] = spans[index].replace(preindentRegex, '\n');
      nodes.push(reindent(node, indentation[0].length - 1));
    } else {
      nodes.push(node);
    }

    index++;
  }

  return {
    language: code.language,
    spans,
    nodes
  };
}

function integrate(code) {
  if (typeof code === 'string') return code;
  return String.raw({
    raw: code.spans
  }, ...code.nodes.map(n => integrate(n)));
}

function isLevelEquivilant(one, two) {
  if (one === null || two === null) return false;

  if (typeof one === 'string' && typeof two !== 'string' || typeof one !== 'string' && typeof two === 'string') {
    return false;
  }

  if (typeof one === 'string' && typeof two === 'string') {
    return one === two;
  }

  if (typeof one !== 'string' && typeof two !== 'string') {
    if (one.spans.length !== two.spans.length) return false;
    return one.spans.every((span, i) => span === two.spans[i]);
  }

  throw new Error('Could not determine equivilance of nodes');
}

function chars(tokens) {
  return tokens.flatMap(({
    code,
    color
  }) => {
    return code.split('').map(c => ({
      code: c,
      color
    }));
  });
}

function tokens(chars) {
  const result = [];
  let token = null;

  for (const char of chars) {
    if (token == null) {
      token = char;
    } else {
      if (char.code === '\n') {
        result.push(token);
        token = null;
      } else if (token.color === char.color && token.morph === char.morph) {
        token.code += char.code;
      } else {
        result.push(token);
        token = char;
      }
    }
  }

  if (token != null) result.push(token);
  return result;
}

function diff(start, end, options) {
  start = reindent(start);
  end = reindent(end);
  const startParsed = chars(parse(start, options));
  const endParsed = chars(parse(end, options));
  let index = 0;
  let endex = 0;
  const result = [];

  function recurse(one, two) {
    const progress = (l, r) => {
      if (r == null) r = l;
      const startIndex = index;

      while (index < startIndex + l.length && index < startParsed.length) {
        result.push({
          code: startParsed[index].code,
          color: startParsed[index].color,
          morph: l === r ? 'retain' : 'delete'
        });
        index++;
      }

      const endIndex = endex;

      while (endex < endIndex + r.length && two !== '' && endex < endParsed.length) {
        if (r !== l) {
          result.push({
            code: endParsed[endex].code,
            color: endParsed[endex].color,
            morph: 'create'
          });
        }

        endex++;
      }
    };

    if (isLevelEquivilant(one, two)) {
      if (one == null || two == null) {
        throw new Error('equivilant nodes should not be null');
      }

      if (typeof one === 'string') {
        progress(one);
      } else {
        if (typeof two === 'string') throw new Error();

        for (let n = 0; n < one.nodes.length; n++) {
          progress(one.spans[n]);
          recurse(one.nodes[n], two.nodes[n]);
        }

        progress(one.spans.at(-1) ?? '');
      }
    } else {
      if (typeof one === 'string' && typeof two === 'string') {
        progress(one, two);
      } else if (typeof one === 'string') {
        progress(one, '');
      } else if (typeof two === 'string') {
        progress('', two);
      }

      if (one != null && typeof one !== 'string') {
        for (let n = 0; n < one.nodes.length; n++) {
          progress(one.spans[n], '');
          recurse(one.nodes[n], null);
        }

        progress(one.spans.at(-1) ?? '', '');
      }

      if (two != null && typeof two !== 'string') {
        for (let n = 0; n < two.nodes.length; n++) {
          progress('', two.spans[n]);
          recurse(null, two.nodes[n]);
        }

        progress('', two.spans.at(-1));
      }
    }
  }

  recurse(start, end);
  let [sat, sln, eat, eln] = [0, 0, 0, 0];
  const positioned = result.map(({
    code,
    color,
    morph
  }) => {
    const value = {
      code,
      color,
      morph,
      from: morph === 'create' ? null : [sat, sln],
      to: morph === 'delete' ? null : [eat, eln]
    };

    if (code === '\n') {
      if (morph !== 'create') {
        sat = 0;
        sln++;
      }

      if (morph !== 'delete') {
        eat = 0;
        eln++;
      }
    } else {
      if (morph !== 'create') sat++;
      if (morph !== 'delete') eat++;
    }

    return value;
  });
  const tokenized = tokens(positioned);
  return tokenized.filter(({
    code
  }) => {
    return code.length !== 0 && !/^ +$/.test(code);
  });
}